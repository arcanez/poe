<HTML>
<HEAD>
<TITLE><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> - an event driven threaded application kernel in Perl</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD WIDTH="30">
<img HSPACE="0" VSPACE="0" border="0" src="/images/L-circle.jpg" align="left" alt="" width="30" height="60">
</TD><TD ALIGN="Center" WIDTH=100% BGCOLOR="#000000">
<STRONG><font color="#FFFFFF" size="5"><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> - an event driven threaded application kernel in Perl</font></STRONG></TD><TD>
<img HSPACE="0" VSPACE="0" border="0" src="/images/R-circle.jpg" align="right" alt="" width="30" height="60">
</TD></TR></TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#public kernel methods">PUBLIC KERNEL METHODS</A></LI>
	<UL>

		<LI><A HREF="#kernel management and data accessors">Kernel Management and Data Accessors</A></LI>
		<LI><A HREF="#fifo event methods">FIFO Event Methods</A></LI>
		<LI><A HREF="#synchronous events">Synchronous Events</A></LI>
		<LI><A HREF="#delayed events">Delayed Events</A></LI>
		<LI><A HREF="#numeric session ids and symbolic session names (aliases)">Numeric Session IDs and Symbolic Session Names (Aliases)</A></LI>
		<LI><A HREF="#filehandle watcher methods (selects)">Filehandle Watcher Methods (Selects)</A></LI>
		<LI><A HREF="#signal watcher methods">Signal Watcher Methods</A></LI>
		<LI><A HREF="#state management methods">State Management Methods</A></LI>
		<LI><A HREF="#external reference count methods">External Reference Count Methods</A></LI>
		<LI><A HREF="#kernel data accessors">Kernel Data Accessors</A></LI>
	</UL>

	<LI><A HREF="#using poe with other event loops">Using POE with Other Event Loops</A></LI>
	<UL>

		<LI><A HREF="#using poe's debugging features">Using POE's Debugging Features</A></LI>
	</UL>

	<LI><A HREF="#poe::kernel exports"><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> Exports</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> - an event driven threaded application kernel in Perl</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<P>POE comes with its own event loop, which is based on <A HREF="#item_select"><CODE>select()</CODE></A> and
written entirely in Perl.  To use it, simply:</P>
<PRE>
  use POE;</PRE>
<P>POE's event loop will also work cooperatively with Gtk's, Tk's or
Event's.  POE will see either of these three modules if it's used
first and change its behavior accordingly.</P>
<PRE>
  use Gtk;  # or use Tk; or use Event;
  use POE;</PRE>
<P>Methods to manage the process' global Kernel instance:</P>
<PRE>
  # Retrieve the kernel's unique identifier.
  $kernel_id = $kernel-&gt;ID;</PRE>
<PRE>
  # Run the event loop, only returning when it has no more sessions to
  # dispatche events to.
  $poe_kernel-&gt;run();</PRE>
<P>FIFO event methods:</P>
<PRE>
  # Post an event to an arbitrary session.
  $kernel-&gt;post( $session, $state_name, @state_args );</PRE>
<PRE>
  # Post an event back to the current session.
  $kernel-&gt;yield( $state_name, @state_args );</PRE>
<PRE>
  # Call a state synchronously, bypassing the event queue and
  # returning the state's return value.
  $state_return_value = $kernel-&gt;call( $session, $state_name, @state_args );</PRE>
<P>Alarm and delay methods:</P>
<PRE>
  # Post an event which will be delivered at a given Unix epoch time.
  # time.  This clears previous timed events with the same state name.
  $kernel-&gt;alarm( $state_name, $epoch_time, @state_args );</PRE>
<PRE>
  # Post an additional alarm, leaving existing ones in the queue.
  $kernel-&gt;alarm_add( $state_name, $epoch_time, @state_args );</PRE>
<PRE>
  # Post an event which will be delivered after a delay, specified in
  # seconds hence. This clears previous timed events with the same
  # state name.
  $kernel-&gt;delay( $state_name, $seconds, @state_args );</PRE>
<PRE>
  # Post an additional delay, leaving existing ones in the queue.
  $kernel-&gt;delay_add( $state_name, $seconds, @state_args );</PRE>
<PRE>
  # Return the names of pending timed events.
  @state_names = $kernel-&gt;queue_peek_alarms( );</PRE>
<P>Symbolic name, or session alias methods:</P>
<PRE>
  # Set an alias for the current session.
  $status = $kernel-&gt;alias_set( $alias );</PRE>
<PRE>
  # Clear an alias for the current session:
  $status = $kernel-&gt;alias_remove( $alias );</PRE>
<PRE>
  # Resolve an alias into a session reference.  Most <A HREF=/docs/POE/Kernel.html>POE::Kernel</A>
  # methods do this for you.
  $session_reference = $kernel-&gt;alias_resolve( $alias );</PRE>
<PRE>
  # Resolve a session ID to a session reference.  The alias_resolve
  # method does this as well, but this is faster.
  $session_reference = $kernel-&gt;ID_id_to_session( $session_id );</PRE>
<PRE>
  # Return a session ID for a session reference.  It is functionally
  # equivalent to $session-&gt;ID.
  $session_id = $kernel-&gt;ID_session_to_id( $session_reference );</PRE>
<P>Filehandle watcher methods:</P>
<PRE>
  # Watch for read readiness on a filehandle.
  $kernel-&gt;select_read( $file_handle, $state_name );</PRE>
<PRE>
  # Stop watching a filehandle for read-readiness.
  $kernel-&gt;select_read( $file_handle );</PRE>
<PRE>
  # Watch for write readiness on a filehandle.
  $kernel-&gt;select_write( $file_handle, $state_name );</PRE>
<PRE>
  # Stop watching a filehandle for write-readiness.
  $kernel-&gt;select_write( $file_handle );</PRE>
<PRE>
  # Pause and resume write readiness watching.  These have lower
  # overhead than full select_write() calls.
  $kernel-&gt;select_pause_write( $file_handle );
  $kernel-&gt;select_resume_write( $file_handle );</PRE>
<PRE>
  # Pause and resume read readiness watching.  These have lower
  # overhead than full select_read() calls.
  $kernel-&gt;select_pause_read( $file_handle );
  $kernel-&gt;select_resume_read( $file_handle );</PRE>
<PRE>
  # Watch for out-of-bound (expedited) read readiness on a filehandle.
  $kernel-&gt;select_expedite( $file_handle, $state_name );</PRE>
<PRE>
  # Stop watching a filehandle for out-of-bound data.
  $kernel-&gt;select_expedite( $file_handle );</PRE>
<PRE>
  # Set and/or clear a combination of selects in one call.
  $kernel-&gt;select( $file_handle,
                   $read_state_name,     # or undef to clear it
                   $write_state_name,    # or undef to clear it
                   $expedite_state_same, # or undef to clear it
                 );</PRE>
<P>Signal watcher and generator methods:</P>
<PRE>
  # Generate an event when a particular signal arrives.
  $kernel-&gt;sig( $signal_name, $state_name );</PRE>
<PRE>
  # Stop watching for a signal.
  $kernel-&gt;sig( $signal_name );</PRE>
<PRE>
  # Post a signal through POE rather than through the underlying OS.
  # This only works within the same process.
  $kernel-&gt;signal( $session, $signal_name );</PRE>
<P>State management methods:</P>
<PRE>
  # Remove an existing state from the current Session.
  $kernel-&gt;state( $state_name );</PRE>
<PRE>
  # Add a new inline state, or replace an existing one.
  $kernel-&gt;state( $state_name, $code_reference );</PRE>
<PRE>
  # Add a new object or package state, or replace an existing one.
  # The object method will be the same as the state name.
  $kernel-&gt;state( $state_name, $object_ref_or_package_name );</PRE>
<PRE>
  # Add a new object or package state, or replace an existing one.
  # The object method may be different from the state name.
  $kernel-&gt;state( $state_name, $object_ref_or_package_name, $method_name );</PRE>
<P>External reference count methods:</P>
<PRE>
  # Increment a session's external reference count.
  $kernel-&gt;refcount_increment( $session_id, $refcount_name );</PRE>
<PRE>
  # Decrement a session's external reference count.
  $kernel-&gt;refcount_decrement( $session_id, $refcount_name );</PRE>
<P>Kernel data accessors:</P>
<PRE>
  # Return a reference to the currently active session, or to the
  # kernel if called outside any session.
  $session = $kernel-&gt;get_active_session();</PRE>
<P>Exported symbols:</P>
<PRE>
  # A reference to the global <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> instance.
  $poe_kernel</PRE>
<PRE>
  # The Gtk or Tk top-level (or main) window widget.  POE uses it
  # internally to attach to toolkits' event loops and to detect
  # process closure so it can generate UIDESTROY signals.
  $poe_main_window</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> is an event application kernel.  It provides a
lightweight, cooperatively-timesliced process model in addition to the
usual basic event loop functions.</P>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> cooperates with three external event loops.  This is
discussed after the public methods are described.</P>
<P>The <A HREF=/docs/POE.html>POE manpage</A> describes a shortcut for using several POE modules at
once.  It also includes a complete sample program with a brief
walkthrough of its parts.</P>
<P>
<HR>
<H1><A NAME="public kernel methods">PUBLIC KERNEL METHODS</A></H1>
<P>This section discusses in more detail the <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> methods that
appear in the SYNOPSIS.</P>
<P>
<H2><A NAME="kernel management and data accessors">Kernel Management and Data Accessors</A></H2>
<P>These functions manipulate the Kernel itself or retrieve information
from it.</P>
<DL>
<DT><STRONG><A NAME="item_ID">ID</A></STRONG><BR>
<DD>
<A HREF="#item_ID"><CODE>ID()</CODE></A> returns the kernel's unique identifier.
<PRE>
  print &quot;The currently running Kernel is: $kernel-&gt;ID\n&quot;;</PRE>
<P>Every <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> instance is assigned an ID at birth.  This ID tries
to differentiate any given instance from all the others, even if they
exist on the same machine.  The ID is a hash of the machine's name and
the kernel's instantiation time and process ID.</P>
<PRE>
  ~/perl/poe$ perl -wl -MPOE -e 'print $poe_kernel-&gt;ID'
  rocco.homenet-39240c97000001d8</PRE>
<P></P>
<DT><STRONG><A NAME="item_run">run</A></STRONG><BR>
<DD>
<A HREF="#item_run"><CODE>run()</CODE></A> starts the kernel's event loop.  It returns only after every
session has stopped, or immediately if no sessions have yet been
started.
<PRE>
  #!/usr/bin/perl -w
  use strict;
  use POE;</PRE>
<PRE>
  # ... start bootstrap session(s) ...</PRE>
<PRE>
  $poe_kernel-&gt;run();
  exit;</PRE>
<P>The <A HREF="#item_run"><CODE>run()</CODE></A> method does not return a meaningful value.</P>
<P></P></DL>
<P>
<H2><A NAME="fifo event methods">FIFO Event Methods</A></H2>
<P>FIFO events are dispatched in the order in which they were queued.
These methods queue new FIFO events.  A session will not spontaneously
stop as long as it has at least one FIFO event in the queue.</P>
<DL>
<DT><STRONG><A NAME="item_post_SESSION%2C_STATE_NAME%2C_PARAMETER_LIST">post SESSION, STATE_NAME, PARAMETER_LIST</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_post_SESSION%2C_STATE_NAME">post SESSION, STATE_NAME</A></STRONG><BR>
<DD>
<CODE>post()</CODE> enqueues an event to be dispatched to STATE_NAME in SESSION.
If a PARAMETER_LIST is included, its values will be passed as
arguments to STATE_NAME's handler.
<PRE>
  $_[KERNEL]-&gt;post( $session, 'do_this' );
  $_[KERNEL]-&gt;post( $session, 'do_that', $with_this, $and_this );
  $_[KERNEL]-&gt;post( $session, 'do_that', @with_these );</PRE>
<PRE>
  <A HREF=/docs/POE/Session.html>POE::Session</A>-&gt;new(
    do_this =&gt; sub { print &quot;do_this called with $_[ARG0] and $_[ARG1]\n&quot; },
    do_that =&gt; sub { print &quot;do_that called with @_[ARG0..$#_]\n&quot; },
  );</PRE>
<P>The <CODE>post()</CODE> method returns a boolean value indicating whether the event
was enqueued successfully.  $! will explain why the <CODE>post()</CODE> failed:</P>
<DL>
<DT><STRONG><A NAME="item_ESRCH">ESRCH</A></STRONG><BR>
<DD>
SESSION did not exist at the time of the <CODE>post()</CODE> call.
<P></P></DL>
<DT><STRONG><A NAME="item_yield_STATE_NAME%2C_PARAMETER_LIST">yield STATE_NAME, PARAMETER_LIST</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_yield_STATE_NAME">yield STATE_NAME</A></STRONG><BR>
<DD>
<CODE>yield()</CODE> enqueues an event to be dispatched to STATE_NAME in the same
session.  If a PARAMETER_LIST is included, its values will be passed
as argumets to STATE_NAME's handler.
<P>Events posted with <CODE>yield()</CODE> must propagate through POE's FIFO before
they're dispatched.  This effectively yields timeslices to other
sessions which have events enqueued before it.</P>
<PRE>
  $kernel-&gt;yield( 'do_this' );
  $kernel-&gt;yield( 'do_that', @with_these );</PRE>
<P>The <CODE>yield()</CODE> method does not return a meaningful value.</P>
<P></P></DL>
<P>
<H2><A NAME="synchronous events">Synchronous Events</A></H2>
<P>Sometimes it's necessary to invoke a state right away, for example to
handle a time-critical external event that would be spoiled by the
time an event propagated through POE's FIFO.  The kernel's <CODE>call()</CODE>
method provides for time-critical events.</P>
<DL>
<DT><STRONG><A NAME="item_call_SESSION%2C_STATE_NAME%2C_PARAMETER_LIST">call SESSION, STATE_NAME, PARAMETER_LIST</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_call_SESSION%2C_STATE_NAME">call SESSION, STATE_NAME</A></STRONG><BR>
<DD>
<CODE>call()</CODE> bypasses the FIFO to call STATE_NAME in a SESSION, optionally
with values from a PARAMETER_LIST.  The values will be passed as
arguments to STATE_NAME at dispatch time.
<P><CODE>call()</CODE> returns whatever STATE_NAME's handler does.  The <CODE>call()</CODE> call's
status is returned in $!, which is 0 for success or a nonzero reason
for failure.</P>
<PRE>
  $return_value = $kernel-&gt;call( 'do_this_now' );
  die &quot;could not do_this_now: $!&quot; if $!;</PRE>
<P>POE uses <CODE>call()</CODE> to dispatch some resource events without FIFO latency.
Filehandle watchers, for example, would continue noticing a handle's
readiness until the it was serviced by a state.  This could result in
several redundant readiness events being enqueued before the first one
was dispatched.</P>
<P>Reasons why <CODE>call()</CODE> might fail:</P>
<DL>
<DT><STRONG>ESRCH</STRONG><BR>
<DD>
SESSION did not exist at the time <CODE>call()</CODE> was called.
<P></P></DL>
</DL>
<P>
<H2><A NAME="delayed events">Delayed Events</A></H2>
<P>POE also manages timed events.  These are events that should be
dispatched after at a certain time or after some time has elapsed.  A
session will not spontaneously stop as long as it has at least one
pending timed event.  Alarms and delays always are enqueued for the
current session, so a SESSION parameter is not needed.</P>
<P>The kernel manages two types of timed event.  Alarms are set to be
dispatched at a particular time, and delays are set to go off after a
certain interval.</P>
<P>If Time::HiRes is installed, <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> will use it to increase the
accuracy of timed events.  The kernel will use the less accurate
built-in <CODE>time()</CODE> if Time::HiRes isn't available.</P>
<DL>
<DT><STRONG><A NAME="item_alarm_STATE_NAME%2C_EPOCH_TIME%2C_PARAMETER_LIST">alarm STATE_NAME, EPOCH_TIME, PARAMETER_LIST</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_alarm_STATE_NAME%2C_EPOCH_TIME">alarm STATE_NAME, EPOCH_TIME</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_alarm_STATE_NAME">alarm STATE_NAME</A></STRONG><BR>
<DD>
<A HREF=/docs/POE/Kernel.html>POE::Kernel</A>'s <CODE>alarm()</CODE> is a single-shot alarm.  It first clears all the
timed events destined for STATE_NAME in the current session.  It then
may set a new alarm for STATE_NAME if EPOCH_TIME is included,
optionally including values from a PARAMETER_LIST.
<P>It is possible to post an alarm with an EPOCH_TIME in the past; in
that case, it will be dispached immediately.</P>
<P>To clear existing timed events for 'do_this' and set a new alarm with
parameters:</P>
<PRE>
  $kernel-&gt;alarm( 'do_this', $at_this_time, @with_these_parameters );</PRE>
<P>Clear existing timed events for 'do_that' and set a new alarm without
parameters:</P>
<PRE>
  $kernel-&gt;alarm( 'do_that', $at_this_time );</PRE>
<P>To clear existing timed events for 'do_the_other_thing' without
setting a new alarm:</P>
<PRE>
  $kernel-&gt;alarm( 'do_the_other_thing' );</PRE>
<P>This method will clear both alarms and delays.</P>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A>'s <CODE>alarm()</CODE> returns 0 on success or a reason for its
failure:</P>
<DL>
<DT><STRONG><A NAME="item_EINVAL">EINVAL</A></STRONG><BR>
<DD>
STATE_NAME is undefined.
<P></P></DL>
<DT><STRONG><A NAME="item_alarm_add_STATE_NAME%2C_EPOCH_TIME%2C_PARAMETER_LI">alarm_add STATE_NAME, EPOCH_TIME, PARAMETER_LIST</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_alarm_add_STATE_NAME%2C_EPOCH_TIME">alarm_add STATE_NAME, EPOCH_TIME</A></STRONG><BR>
<DD>
<CODE>alarm_add()</CODE> sets an additional timed event for STATE_NAME in the
current session without clearing pending timed events.  The new alarm
event will be dispatched no earlier than EPOCH_TIME.
<P>To enqueue additional alarms for 'do_this':</P>
<PRE>
  $kernel-&gt;alarm_add( 'do_this', $at_this_time, @with_these_parameters );
  $kernel-&gt;alarm_add( 'do_this', $at_this_time );</PRE>
<P>Additional alarms can be cleared with <A HREF=/docs/POE/Kernel.html>POE::Kernel</A>'s <CODE>alarm()</CODE> method.</P>
<P><CODE>alarm_add()</CODE> returns 0 on success or a reason for failure:</P>
<DL>
<DT><STRONG>EINVAL</STRONG><BR>
<DD>
Either STATE_NAME or EPOCH_TIME is undefined.
<P></P></DL>
<DT><STRONG><A NAME="item_delay_STATE_NAME%2C_SECONDS%2C_PARAMETER_LIST">delay STATE_NAME, SECONDS, PARAMETER_LIST</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_delay_STATE_NAME%2C_SECONDS">delay STATE_NAME, SECONDS</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_delay_STATE_NAME">delay STATE_NAME</A></STRONG><BR>
<DD>
<CODE>delay()</CODE> is a single-shot delayed event.  It first clears all the timed
events destined for STATE_NAME in the current session.  If SECONDS is
included, it will set a new delay for STATE_NAME to be dispatched
SECONDS seconds hence, optionally including values from a
PARAMETER_LIST.
<P><CODE>delay()</CODE> uses whichever <CODE>time(2)</CODE> is available within <A HREF=/docs/POE/Kernel.html>POE::Kernel</A>.  That
may be the more accurate Time::HiRes::time(), or perhaps not.
Regardless, <CODE>delay()</CODE> will do the right thing without sessions testing
for Time::HiRes themselves.</P>
<P>It's possible to post delays with negative SECONDS; in those cases,
they will be dispatched immediately.</P>
<P>To clear existing timed events for 'do_this' and set a new delay with
parameters:</P>
<PRE>
  $kernel-&gt;delay( 'do_this', $after_this_much_time, @with_these );</PRE>
<P>Clear existing timed events for 'do_that' and set a new delay without
parameters:</P>
<PRE>
  $kernel-&gt;delay( 'do_this', $after_this_much_time );</PRE>
<P>To clear existing timed events for 'do_the_other_thing' without
setting a new delay:</P>
<PRE>
  $kernel-&gt;delay( 'do_the_other_thing' );</PRE>
<P><CODE>delay()</CODE> returns 0 on success or a reason for its failure:</P>
<DL>
<DT><STRONG>EINVAL</STRONG><BR>
<DD>
STATE_NAME is undefined.
<P></P></DL>
<DT><STRONG><A NAME="item_delay_add_STATE_NAME%2C_SECONDS%2C_PARAMETER_LIST">delay_add STATE_NAME, SECONDS, PARAMETER_LIST</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_delay_add_STATE_NAME%2C_SECONDS">delay_add STATE_NAME, SECONDS</A></STRONG><BR>
<DD>
<CODE>delay_add()</CODE> sets an additional delay for STATE_NAME in the current
session without clearing pending timed events.  The new delay will be
dispatched no sooner than SECONDS seconds hence.
<P>To enqueue additional delays for 'do_this':</P>
<PRE>
  $kernel-&gt;delay_add( 'do_this', $after_this_much_time, @with_these );
  $kernel-&gt;delay_add( 'do_this', $after_this_much_time );</PRE>
<P>Additional alarms cas be cleared with <A HREF=/docs/POE/Kernel.html>POE::Kernel</A>'s <CODE>delay()</CODE> method.</P>
<P><CODE>delay_add()</CODE> returns 0 on success or a reason for failure:</P>
<DL>
<DT><STRONG>EINVAL</STRONG><BR>
<DD>
Either STATE_NAME or SECONDS is undefined.
<P></P></DL>
<DT><STRONG><A NAME="item_queue_peek_alarms">queue_peek_alarms</A></STRONG><BR>
<DD>
<A HREF="#item_queue_peek_alarms"><CODE>queue_peek_alarms()</CODE></A> returns a time-ordered list of state names from
the current session that have pending timed events.  If a state has
more than one pending timed event, it will be listed that many times.
<PRE>
  my @pending_timed_events = $kernel-&gt;queue_peek_alarms();</PRE>
<P></P></DL>
<P>
<H2><A NAME="numeric session ids and symbolic session names (aliases)">Numeric Session IDs and Symbolic Session Names (Aliases)</A></H2>
<P>Every session is given a unique ID at birth.  This ID combined with
the kernel's own ID can uniquely identify a particular session
anywhere in the world.</P>
<P>Sessions can also use the kernel's alias dictionary to give themselves
symbolic names.  Once a session has a name, it may be referred to by
that name wherever a kernel method expects a session reference or ID.</P>
<P>Sessions with aliases are treated as daemons within the current
program (servlets?).  They are kept alive even without other things to
do on the assumption that some other session will need their services.</P>
<P>Daemonized sessions may spontaneously self-destruct if no other
sessions are active.  This prevents ``zombie'' servlets from keeping a
program running with nothing to do.</P>
<DL>
<DT><STRONG><A NAME="item_alias_set_ALIAS">alias_set ALIAS</A></STRONG><BR>
<DD>
<CODE>alias_set()</CODE> sets an ALIAS for the current session.  The ALIAS may then
be used nearly everywhere a session reference or ID is expected.
Sessions may have more than one alias, and each must be defined in a
separate <CODE>alias_set()</CODE> call.
<PRE>
  $kernel-&gt;alias_set( 'ishmael' ); # o/` A name I call myself. o/`</PRE>
<P>Having an alias ``daemonizes'' a session, allowing it to stay alive even
when there's nothing for it to do.  Sessions can use this to become
autonomous services that other sessions refer to by name.</P>
<PRE>
  $kernel-&gt;alias_set( 'httpd' );
  $kernel-&gt;post( httpd =&gt; set_handler =&gt; $uri_regexp =&gt; 'callback_event' );</PRE>
<P><CODE>alias_set()</CODE> returns 0 on success, or a nonzero failure indicator:</P>
<DL>
<DT><STRONG><A NAME="item_EEXIST">EEXIST</A></STRONG><BR>
<DD>
The alias already is assigned to a different session.
<P></P></DL>
<DT><STRONG><A NAME="item_alias_remove_ALIAS">alias_remove ALIAS</A></STRONG><BR>
<DD>
<CODE>alias_remove()</CODE> clears an existing ALIAS from the current session.  The
ALIAS will no longer refer to this session, and some other session may
claim it.
<PRE>
  $kernel-&gt;alias_remove( 'Shirley' ); # And don't call me Shirley.</PRE>
<P>If a session is only being kept alive by its aliases, it will stop
once they are removed.</P>
<P><CODE>alias_remove()</CODE> returns 0 on success or a reason for its failure:</P>
<DL>
<DT><STRONG>ESRCH</STRONG><BR>
<DD>
The Kernel's dictionary does not include the ALIAS being removed.
<P></P>
<DT><STRONG><A NAME="item_EPERM">EPERM</A></STRONG><BR>
<DD>
ALIAS belongs to some other session, and the current one does not have
the authority to clear it.
<P></P></DL>
<DT><STRONG><A NAME="item_alias_resolve_ALIAS">alias_resolve ALIAS</A></STRONG><BR>
<DD>
<CODE>alias_resolve()</CODE> returns a session reference corresponding to its given
ALIAS.  This method has been overloaded over time, and now ALIAS may
be several things:
<P>An alias:</P>
<PRE>
  $session_reference = $kernel-&gt;alias_resolve( 'irc_component' );</PRE>
<P>A stringified session reference.  This is a form of weak reference:</P>
<PRE>
  $blessed_session_reference = $kernel-&gt;alias_resolve( &quot;$stringified_one&quot; );</PRE>
<P>A numeric session ID:</P>
<PRE>
  $session_reference = $kernel-&gt;alias_resolve( $session_id );</PRE>
<P><CODE>alias_resolve()</CODE> returns undef upon failure, setting $! to explain the
error:</P>
<DL>
<DT><STRONG>ESRCH</STRONG><BR>
<DD>
The Kernel's dictionary does not include ALIAS.
<P></P></DL>
<P>These functions work directly with session IDs.  They are faster than
<CODE>alias_resolve()</CODE> in the specific cases where they're useful.</P>
<DT><STRONG><A NAME="item_ID_id_to_session_SESSION_ID">ID_id_to_session SESSION_ID</A></STRONG><BR>
<DD>
<CODE>ID_id_to_session()</CODE> returns a session reference for a given numeric
session ID.
<PRE>
  $session_reference = ID_id_to_session( $session_id );</PRE>
<P>It returns undef if a lookup fails, and it sets $! to explain why the
lookup failed.</P>
<DL>
<DT><STRONG>ESRCH</STRONG><BR>
<DD>
The session ID does not refer to a running session.
<P></P></DL>
<DT><STRONG><A NAME="item_ID_session_to_id_SESSION_REFERENCE">ID_session_to_id SESSION_REFERENCE</A></STRONG><BR>
<DD>
<CODE>ID_session_to_id()</CODE> returns the ID associated with a session reference.
This is virtually identical to SESSION_REFERENCE-&gt;ID, except that
SESSION_REFERENCE may have been stringified.  For example, this will
work, provided that the session exists:
<PRE>
  $session_id = ID_session_to_id( &quot;$session_reference&quot; );</PRE>
<P><CODE>ID_session_to_id()</CODE> returns undef if a lookup fails, and it sets $! to
explain why the lookup failed.</P>
<DL>
<DT><STRONG>ESRCH</STRONG><BR>
<DD>
The session reference does not describe a session which is currently
running.
<P></P></DL>
</DL>
<P>
<H2><A NAME="filehandle watcher methods (selects)">Filehandle Watcher Methods (Selects)</A></H2>
<P>Selects emit synchronous events when filehandles become ready.
Synchronous events bypass the FIFO queue so that time-critical
handlers may run right away.</P>
<P>Select handlers are expected to deal with filehandles so that they
stop being ready.  For example, a <CODE>select_read()</CODE> handler should try to
read as much data from a filehandle as it can.</P>
<P>Select events include one parameter, <CODE>ARG0</CODE>, which contains the
handle for the file that is ready.  <CODE>ARG0</CODE> and the other event
handler parameter constants is covered in <A HREF="/POE/Session.html">the <A HREF=/docs/POE/Session.html>POE::Session</A> manpage</A>.</P>
<P>Sessions will not spontaneously stop as long as they are watching at
least one filehandle.</P>
<DL>
<DT><STRONG><A NAME="item_select_read_FILE_HANDLE%2C_STATE_NAME">select_read FILE_HANDLE, STATE_NAME</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_select_read_FILE_HANDLE">select_read FILE_HANDLE</A></STRONG><BR>
<DD>
<CODE>select_read()</CODE> starts or stops the kernel from watching to see if a
filehandle can be read.  The Kernel will call the handler for
STATE_NAME whenever the filehandle has data to be read.
<PRE>
  # Emit 'do_a_read' whenever $filehandle has data to be read.
  $kernel-&gt;select_read( $filehandle, 'do_a_read' );</PRE>
<PRE>
  # Stop watching for $filehandle to be readable.
  $kernel-&gt;select_read( $filehandle );</PRE>
<P><CODE>select_read()</CODE> does not return a meaningful value.</P>
<P></P>
<DT><STRONG><A NAME="item_select_write_FILE_HANDLE%2C_STATE_NAME">select_write FILE_HANDLE, STATE_NAME</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_select_write_FILE_HANDLE">select_write FILE_HANDLE</A></STRONG><BR>
<DD>
<CODE>select_write()</CODE> starts or stops the kernel from watching to see if a
filehandle can be written to.  The Kernel will call the handler for
STATE_NAME whenever the filehandle has room for new data to be
written.
<PRE>
  # Emit 'flush_data' whenever $filehandle can be written.
  $kernel-&gt;select_writ( $filehandle, 'flush_data' );</PRE>
<PRE>
  # Stop watching for $filehandle to be writable.
  $kernel-&gt;select_write( $filehandle );</PRE>
<P><CODE>select_write()</CODE> does not return a meaningful value.</P>
<P></P>
<DT><STRONG><A NAME="item_select_expedite_FILE_HANDLE%2C_STATE_NAME">select_expedite FILE_HANDLE, STATE_NAME</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_select_expedite_FILE_HANDLE">select_expedite FILE_HANDLE</A></STRONG><BR>
<DD>
<CODE>select_expedite()</CODE> starts or stops the kernel from watching to see if a
filehandle can be read out-of-band.  The Kernel will call the handler
for STATE_NAME whenever the filehandle has out-of-band data to be
read.
<PRE>
  # Emit 'do_an_oob_read' whenever $filehandle has data to be read.
  $kernel-&gt;select_expedite( $filehandle, 'do_an_oob_read' );</PRE>
<PRE>
  # Stop watching for expedited data on the $filehandle.
  $kernel-&gt;select_expedite( $filehandle );</PRE>
<P><CODE>select_expedite()</CODE> does not return a meaningful value.</P>
<P></P>
<DT><STRONG><A NAME="item_select_pause_write_FILE_HANDLE">select_pause_write FILE_HANDLE</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_select_resume_write_FILE_HANDLE">select_resume_write FILE_HANDLE</A></STRONG><BR>
<DD>
<CODE>select_pause_write()</CODE> temporarily pauses event generation when a
FILE_HANDLE can be written to.  <CODE>select_resume_write()</CODE> turns event
generation back on.
<P>These functions are more efficient than <CODE>select_write()</CODE> because they
don't perform full resource management.</P>
<P>Pause and resume a filehandle's writable events:</P>
<PRE>
  $kernel-&gt;select_pause_write( $filehandle );
  $kernel-&gt;select_resume_write( $filehandle );</PRE>
<P>These methods don't return meaningful values.</P>
<P></P>
<DT><STRONG><A NAME="item_select_FILE_HANDLE%2C_READ_STATE_NM%2C_WRITE_STATE">select FILE_HANDLE, READ_STATE_NM, WRITE_STATE_NM, EXPEDITE_STATE_NM</A></STRONG><BR>
<DD>
<A HREF=/docs/POE/Kernel.html>POE::Kernel</A>'s <A HREF="#item_select"><CODE>select()</CODE></A> method alters a filehandle's read, write, and
expedite selects at the same time.  It's one method call more
expensive than doing the same thing manually, but it's more convenient
to code.
<P>Defined state names set or change the events that will be emitted when
the filehandle becomes ready.  Undefined names clear those aspects of
the watcher, stopping it from generating those types of events.</P>
<P>This sets all three types of events at once.</P>
<PRE>
  $kernel-&gt;select( $filehandle, 'do_read', 'do_flush', 'do_read_oob' );</PRE>
<P>This clears all three types of events at once.  If this filehandle is
the only thing keeping a session alive, then clearing its selects will
stop the session.</P>
<PRE>
  $kernel-&gt;select( $filehandle );</PRE>
<P>This sets up a filehandle for read-only operation.</P>
<PRE>
  $kernel-&gt;select( $filehandle, 'do_read', undef, 'do_read_oob' );</PRE>
<P>This sets up a filehandle for write-only operation.</P>
<PRE>
  $kernel-&gt;select( $filehandle, undef, 'do_flush' );</PRE>
<P>This method does not return a meaningful value.</P>
<P></P></DL>
<P>
<H2><A NAME="signal watcher methods">Signal Watcher Methods</A></H2>
<P>Sessions always receive events for signals.  By default, signals are
sent as _signal events.  Signal ``watchers'' just map particular signals
to events other than _signal.</P>
<P>The default _signal event is covered in more detail in
<A HREF="/POE/Session.html">the <A HREF=/docs/POE/Session.html>POE::Session</A> manpage</A>, along with the other standard events.</P>
<P>Signal watchers do not prevent sessions from spontaneously stopping.</P>
<P>Perl's signal handling is not safe by itself, and while POE tries its
best to avoid signal problems, they will occur.  The Event module
implements safe signals, and POE will take advantage of them when
Event is used before it.</P>
<P>Signal events propagate from a session's children up to it.  This
ensures that the leaves of a session's family tree are signalled
before branches, and so on up to it.  By the time a session receives a
signal, all its descendents already have.</P>
<P>The Kernel acts as the ancestor of every session.  Signalling it, as
the operating system does, propagates signal events to every session.</P>
<P>It's possible to post fictitious signals from within POE.  These are
injected into the queue as if they came from the underlying operating
system, but they are not limited to the signals that the system
recognizes.  POE uses fictitious signals to notify every session about
certain global events.</P>
<P>Sessions that don't handle signal events may incur side effects.
Event handlers tell the Kernel that they've handled a signal by
returning true.  The Kernel will consider a signal unhandled if its
event handler returns false or doesn't exist.  Either way, the signal
will continue propagating up the ancestor tree.</P>
<P>There are three signal levels.  They are listed from least to most
strident.</P>
<DL>
<DT><STRONG><A NAME="item_benign">benign</A></STRONG><BR>
<DD>
Benign signals just notify sessions that signals have been caught.
They have no side effects if they aren't handled.
<P></P>
<DT><STRONG><A NAME="item_terminal">terminal</A></STRONG><BR>
<DD>
Terminal signals will stop any session that doesn't handle them.  The
terminal system signals are: HUP, INT, KILL, QUIT and TERM.  There is
also one terminal fictitious signal, IDLE, which is used to notify
leftover sessions that the program has run out of things to do.
<P></P>
<DT><STRONG><A NAME="item_nonmaskable">nonmaskable</A></STRONG><BR>
<DD>
Nonmaskable signals are similar to terminal signals, but they stop a
session regardless of its handler's return value.  There are two nonmaskable signals, both of which are fictitious:
<P>ZOMBIE is fired if the terminal signal IDLE did not wake anything up;
it's used to stop the remaining ``zombie'' sessions so that an inactive
program will exit.</P>
<P>UIDESTROY is fired when a program's main or top-level widget has been
destroyed.  It's used to shut down programs when their interfaces have
been closed.</P>
<P></P></DL>
<P>Some system signals are handled specially.  These are SIGCHLD/SIGCLD,
SIGPIPE, and SIGWINCH.</P>
<DL>
<DT><STRONG><A NAME="item_SIGCHLD%2FSIGCLD_Events">SIGCHLD/SIGCLD Events</A></STRONG><BR>
<DD>
<A HREF=/docs/POE/Kernel.html>POE::Kernel</A> generates the same event when it receives either a SIGCHLD
or SIGCLD signal from the operating system.  This is done so sessions
don't have to worry about which one they'll receive.
<P>Additionally, the Kernel's SIGCHLD/SIGCLD handler determines the
exiting child's process ID and return value on behalf of sessions.
This lets several sessions receive that information without deciding
which will call waitpid(2).</P>
<P>The SIGCHLD/SIGCHLD signal event comes with three custom parameters.
<CODE>ARG0</CODE> contains 'CHLD' even if SIGCLD was caught.  <CODE>ARG1</CODE> contains
the child's process ID.  <CODE>ARG2</CODE> contains the child's return value
from <CODE>$?</CODE>.</P>
<P></P>
<DT><STRONG><A NAME="item_SIGPIPE_Events">SIGPIPE Events</A></STRONG><BR>
<DD>
Normally, system signals are posted to the Kernel so they can
propagate to every session.  SIGPIPE is an exception to this rule;
it's posted to the session that's currently running.  It still will
propagate through that session's children, but it won't go beyond that
parent/child tree.
<P></P>
<DT><STRONG><A NAME="item_SIGWINCH_Events">SIGWINCH Events</A></STRONG><BR>
<DD>
Window resizes can generate a large number of signals very quickly,
and this can easily cause perl to dump core.  Because of this, POE
ignores SIGWINCH outright unless it's using Event's safe signals.
<P></P></DL>
<P>Finally, here are <A HREF=/docs/POE/Kernel.html>POE::Kernel</A>'s signal methods themselves.</P>
<DL>
<DT><STRONG><A NAME="item_sig_SIGNAL_NAME%2C_STATE_NAME">sig SIGNAL_NAME, STATE_NAME</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_sig_SIGNAL_NAME">sig SIGNAL_NAME</A></STRONG><BR>
<DD>
<CODE>sig()</CODE> registers or unregisters a STATE_NAME event for a particular
SIGNAL_NAME.  Signal names are the same as %SIG uses, with one
exception: CLD is always delivered as CHLD, so handling CHLD will
always do the right thing.
<PRE>
  $kernel-&gt;sig( INT =&gt; 'event_sigint' );</PRE>
<P>To unregister a signal handler, just leave off the event it should
generate, or pass it in undefined.</P>
<PRE>
  $kernel-&gt;sig( 'INT' );
  $kernel-&gt;sig( INT =&gt; undef );</PRE>
<P>It's possible to register events for signals that the operating system
will never generate.  These ``fictitious'' signals can however be
generated through POE's <CODE>signal()</CODE> method instead of kill(2).</P>
<P>The <CODE>sig()</CODE> method does not return a meaningful value.</P>
<P></P>
<DT><STRONG><A NAME="item_signal_SESSION%2C_SIGNAL_NAME">signal SESSION, SIGNAL_NAME</A></STRONG><BR>
<DD>
<CODE>signal()</CODE> posts a signal event to a session through <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> rather
than actually signalling the process through the operating system.
Because it injects signal events directly into POE's Kernel, its
SIGNAL_NAME doesn't have to be one the operating system understands.
<P>For example, this posts a fictitious signal to some session:</P>
<PRE>
  $kernel-&gt;signal( $session, 'DIEDIEDIE' );</PRE>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A>'s <CODE>signal()</CODE> method doesn't return a meaningful value.</P>
<P></P></DL>
<P>
<H2><A NAME="state management methods">State Management Methods</A></H2>
<P>State management methods let sessions hot swap their event handlers.
It would be rude to change another session's states, so these methods
only affect the current session.</P>
<DL>
<DT><STRONG><A NAME="item_state_STATE_NAME">state STATE_NAME</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_state_STATE_NAME%2C_CODE_REFERENCE">state STATE_NAME, CODE_REFERENCE</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_state_STATE_NAME%2C_OBJECT_REFERENCE">state STATE_NAME, OBJECT_REFERENCE</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_state_STATE_NAME%2C_OBJECT_REFERENCE%2C_OBJECT_MET">state STATE_NAME, OBJECT_REFERENCE, OBJECT_METHOD_NAME</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_state_STATE_NAME%2C_PACKAGE_NAME">state STATE_NAME, PACKAGE_NAME</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_state_STATE_NAME%2C_PACKAGE_NAME%2C_PACKAGE_METHOD">state STATE_NAME, PACKAGE_NAME, PACKAGE_METHOD_NAME</A></STRONG><BR>
<DD>
Depending on how it's used, <CODE>state()</CODE> can add, remove, or update an
event handler in the current session.
<P>The simplest form of <CODE>state()</CODE> call deletes a handler for an event.
This example removes the current session's ``do_this'' handler.</P>
<PRE>
  $kernel-&gt;state( 'do_this' );</PRE>
<P>The next form assigns a coderef to an event.  If the event is already
being handled, its old handler will be discarded.  Any events already
in POE's queue will be dispatched to the new handler.</P>
<P>Plain coderef handlers are also called ``inline'' handlers because they
originally were defined with inline anonymous subs.</P>
<PRE>
  $kernel-&gt;state( 'do_this', \&amp;this_does_it );</PRE>
<P>The third and fourth forms register or replace a handler with an
object method.  These handlers are called ``object states''.  The third
form maps an event to a method with the same name.</P>
<PRE>
  $kernel-&gt;state( 'do_this', $with_this_object );</PRE>
<P>The fourth form maps an event to a method with a different name.</P>
<PRE>
  $kernel-&gt;state( 'do_this', $with_this_object, $calling_this_method );</PRE>
<P>The fifth and sixth forms register or replace a handler with a package
method.  These handlers are called ``package states''.  The fifth form
maps an event to a function with the same name.</P>
<PRE>
  $kernel-&gt;state( 'do_this', $with_this_package );</PRE>
<P>The sixth form maps an event to a function with a different name.</P>
<PRE>
  $kernel-&gt;state( 'do_this', $with_this_package, $calling_this_function );</PRE>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A>'s <CODE>state()</CODE> method returns 0 on success or a nonzero code
explaining why it failed:</P>
<DL>
<DT><STRONG>ESRCH</STRONG><BR>
<DD>
The Kernel doesn't recognize the currently active session.  This
happens when <CODE>state()</CODE> is called when no session is active.
<P></P></DL>
</DL>
<P>
<H2><A NAME="external reference count methods">External Reference Count Methods</A></H2>
<P>The Kernel internally maintains reference counts on sessions that have
active resource watchers.  The reference counts are used to ensure
that a session doesn't self-destruct while it's doing something
important.</P>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A>'s external reference counting methods let resource watcher
developers manage their own reference counts.  This lets the watchers
keep their sessions alive when necessary.</P>
<DL>
<DT><STRONG><A NAME="item_refcount_increment_SESSION_ID%2C_REFCOUNT_NAME">refcount_increment SESSION_ID, REFCOUNT_NAME</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_refcount_decrement_SESSION_ID%2C_REFCOUNT_NAME">refcount_decrement SESSION_ID, REFCOUNT_NAME</A></STRONG><BR>
<DD>
<CODE>refcount_increment()</CODE> increments a session's external reference count,
returning the reference count after the increment.
<P><CODE>refcount_decrement()</CODE> decrements a session's external reference count,
returning the reference count after the decrement.</P>
<PRE>
  $new_count = $kernel-&gt;refcount_increment( $session_id, 'thingy' );
  $new_count = $kernel-&gt;refcount_decrement( $session_id, 'thingy' );</PRE>
<P>Both methods return undef on failure and set $! to explain the
failure.</P>
<DL>
<DT><STRONG>ESRCH</STRONG><BR>
<DD>
There is no session SESSION_ID currently active.
<P></P></DL>
</DL>
<P>
<H2><A NAME="kernel data accessors">Kernel Data Accessors</A></H2>
<P>The Kernel keeps some information which can be useful to other
libraries.  These functions provide a consistent, safe interface to
the Kernel's internal data.</P>
<DL>
<DT><STRONG><A NAME="item_get_active_session">get_active_session</A></STRONG><BR>
<DD>
<A HREF="#item_get_active_session"><CODE>get_active_session()</CODE></A> returns a reference to the session which is
currently running.  It returns a reference to the Kernel itself if no
other session is running.  This is one of the times where the Kernel
pretends it's just another session.
<PRE>
  my $active_session = $poe_kernel-&gt;get_active_session();</PRE>
<P>This is a convenient way for procedurally called libraries to get a
reference to the current session.  Otherwise a programmer would
tediously need to include <CODE>SESSION</CODE> with every call.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="using poe with other event loops">Using POE with Other Event Loops</A></H1>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> supports four event loops.  Three of them come from other
modules, and the Kernel will adapt to whichever one is loaded before
it.  The Kernel's resource functions are designed to work the same
regardless of the underlying event loop.</P>
<DL>
<DT><STRONG><A NAME="item_select">POE's <CODE>select()</CODE> Loop</A></STRONG><BR>
<DD>
This is the default event loop.  It is included in <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> and
written in plain Perl for maximum portability.
<PRE>
  use POE;</PRE>
<P></P>
<DT><STRONG><A NAME="item_Event%27s_Loop">Event's Loop</A></STRONG><BR>
<DD>
Event is written in C for maximum performance.  It requires either a C
compiler or a binary distribtution for your platform, and its C nature
allows it to implement safe signals.
<PRE>
  use Event;
  use POE;</PRE>
<P></P>
<DT><STRONG><A NAME="item_Gtk%27s_Event_Loop">Gtk's Event Loop</A></STRONG><BR>
<DD>
This loop allows POE to work in graphical programs using the Gtk-Perl
library.
<P></P>
<DT><STRONG><A NAME="item_Tk%27s_Event_Loop">Tk's Event Loop</A></STRONG><BR>
<DD>
This loop allows POE to work in graphical programs using the Tk-Perl
library.
<P></P></DL>
<P>External event loops expect plain coderefs as callbacks.  <A HREF=/docs/POE/Session.html>POE::Session</A>
has a <CODE>postback()</CODE> method which will create callbacks these loops can
use.  Callbacks created with <CODE>postback()</CODE> are designed to post POE
events when called, letting just about any loop's native callbacks
work with POE.  This includes widget callbacks and event watchers POE
never dreamt of.</P>
<P>
<H2><A NAME="using poe's debugging features">Using POE's Debugging Features</A></H2>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> contains a number of debugging assertions and traces.</P>
<P>Assertions remain quiet until something wrong has been detected; then
they die right away with an error.  They're mainly used for sanity
checking in POE's test suite and to make the developers' lives easier.
Traces, on the other hand, are never fatal, but they're terribly
noisy.</P>
<P>Both assertions and traces incur performance penalties, so they should
be used sparingly, if at all.  They all are off by default.  POE's
test suite runs slower than normal because assertions are enabled
during all the tests.</P>
<P>Assertion and tracing constants can be redefined before <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> is
first used.</P>
<PRE>
  # Turn on everything.
  sub POE::Kernel::ASSERT_DEFAULT () { 1 }
  sub POE::Kernel::TRACE_DEFAULT  () { 1 }
  use POE;</PRE>
<P>Assertions will be discussed first.</P>
<DL>
<DT><STRONG><A NAME="item_ASSERT_DEFAULT">ASSERT_DEFAULT</A></STRONG><BR>
<DD>
ASSERT_DEFAULT is used as the default value for all the other assert
constants.  Setting it true is a quick and reliable way to ensure all
assertions are enabled.
<P></P>
<DT><STRONG><A NAME="item_ASSERT_GARBAGE">ASSERT_GARBAGE</A></STRONG><BR>
<DD>
ASSERT_GARBAGE turns on checks for proper garbage collection.  In
particular, it ensures that sessions have released all their resources
before they're destroyed.
<P></P>
<DT><STRONG><A NAME="item_ASSERT_REFCOUNT">ASSERT_REFCOUNT</A></STRONG><BR>
<DD>
ASSERT_REFCOUNT enables checks for negative reference counts.
<P></P>
<DT><STRONG><A NAME="item_ASSERT_RELATIONS">ASSERT_RELATIONS</A></STRONG><BR>
<DD>
ASSERT_RELATIONS turns on parent/child referential integrity checks.
<P></P>
<DT><STRONG><A NAME="item_ASSERT_RETURNS">ASSERT_RETURNS</A></STRONG><BR>
<DD>
ASSERT_RETURNS causes <A HREF=/docs/POE/Kernel.html>POE::Kernel</A>'s methods to croak instead of
returning error codes.  See also TRACE_RETURNS if you don't want the
Kernel to be so strict.
<P></P>
<DT><STRONG><A NAME="item_ASSERT_SELECT">ASSERT_SELECT</A></STRONG><BR>
<DD>
ASSERT_SELECT enables extra error checking in the Kernel's select
logic.  It has no effect if POE is using an external event loop.
<P></P>
<DT><STRONG><A NAME="item_ASSERT_SESSIONS">ASSERT_SESSIONS</A></STRONG><BR>
<DD>
ASSERT_SESSIONS makes it fatal to send an event to a nonexistent
session.
<P></P></DL>
<P>Then there are the trace options.</P>
<DL>
<DT><STRONG><A NAME="item_TRACE_DEFAULT">TRACE_DEFAULT</A></STRONG><BR>
<DD>
TRACE_DEFAULT is used as the default value for all the other trace
constants.  Setting it true is a quick and reliable way to ensure all
traces are enabled.
<P></P>
<DT><STRONG><A NAME="item_TRACE_EVENTS">TRACE_EVENTS</A></STRONG><BR>
<DD>
The music goes around and around, and it comes out here.  TRACE_EVENTS
enables messages that tell what happens to FIFO and alarm events: when
they're queued, dispatched, or discarded, and what their states
return.
<P></P>
<DT><STRONG><A NAME="item_TRACE_GARBAGE">TRACE_GARBAGE</A></STRONG><BR>
<DD>
TRACE_GARBAGE shows what's keeping sessions alive.  It's useful for
determining why a session simply refuses to die, or why it won't stick
around.
<P></P>
<DT><STRONG><A NAME="item_TRACE_PROFILE">TRACE_PROFILE</A></STRONG><BR>
<DD>
TRACE_PROFILE switches on state profiling.  This causes the Kernel to
keep a count of every state it dispatches.  It displays a frequency
report when <A HREF="#item_run"><CODE>run()</CODE></A> is about to return.
<P></P>
<DT><STRONG><A NAME="item_TRACE_QUEUE">TRACE_QUEUE</A></STRONG><BR>
<DD>
TRACE_QUEUE complements TRACE_EVENTS.  When enabled, it traces the
contents of POE's event queues, giving some insight into how events
are ordered.  This has become less relevant since the alarm and FIFO
queues have separated.
<P></P>
<DT><STRONG><A NAME="item_TRACE_REFCOUNT">TRACE_REFCOUNT</A></STRONG><BR>
<DD>
TRACE_REFCOUNT enables debugging output whenever an external reference
count changes.
<P></P>
<DT><STRONG><A NAME="item_TRACE_RETURNS">TRACE_RETURNS</A></STRONG><BR>
<DD>
TRACE_RETURNS enables carping whenever a Kernel method is about to
return an error.  See ASSERT_RETURNS if you'd like the Kernel to be
stricter than this.
<P></P>
<DT><STRONG><A NAME="item_TRACE_SELECT">TRACE_SELECT</A></STRONG><BR>
<DD>
TRACE_SELECT enables or disables statistics about <A HREF="#item_select"><CODE>select()</CODE></A>'s
parameters and return values.  It's only relevant when using POE's own
<A HREF="#item_select"><CODE>select()</CODE></A> loop.
<P></P></DL>
<P>
<HR>
<H1><A NAME="poe::kernel exports"><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> Exports</A></H1>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> exports two symbols for your coding enjoyment: $poe_kernel
and <A HREF="#item_%24poe_main_window"><CODE>$poe_main_window</CODE></A>.  <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> is implicitly used by POE
itself, so using POE gets you <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> (and its exports) for free.</P>
<DL>
<DT><STRONG><A NAME="item_%24poe_kernel">$poe_kernel</A></STRONG><BR>
<DD>
$poe_kernel contains a reference to the process' <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> instance.
It's mainly useful for getting at the kernel from places other than
states.
<P>For example, programs can't call the Kernel's <A HREF="#item_run"><CODE>run()</CODE></A> method without a
reference, and they normally don't get references to the Kernel
without being in a running state.  This gets them going:</P>
<PRE>
  $poe_kernel-&gt;run();</PRE>
<P>It's also handy from within libraries, but states themselves receive
<CODE>KERNEL</CODE> parameters and don't need to use $poe_kernel directly.</P>
<P></P>
<DT><STRONG><A NAME="item_%24poe_main_window">$poe_main_window</A></STRONG><BR>
<DD>
POE creates a ``main'' or a ``top-level'' window to interact with
graphical toolkits' event loops.  Rather than squander this window, it
passes a reference on to the main program so it may be used.  The
reference is passed in the $poe_main_window variable.
<P>$poe_main_window is undefined if a graphical toolkit isn't used.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P>The <A HREF=/docs/POE.html#see also>SEE ALSO section in <EM>POE</EM></A> contains a table of contents covering
the entire POE distribution.</P>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P><CODE>alarm()</CODE> and <CODE>delay()</CODE> clear all the timed events for the current session
and the named state.  It's not possible to clear some and leave
others.</P>
<P>There is no mechanism in place to prevent external reference count
names from clashing.</P>
<P>
<HR>
<H1><A NAME="authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></H1>
<P>Please <A HREF=/docs/POE.html>see <EM>POE</EM></A> for more information about authors and contributors.</P>

</BODY>

</HTML>
