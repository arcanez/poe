<HTML>
<HEAD>
<TITLE><A HREF=/docs/POE/Wheel.html>POE::Wheel</A> - high-level protocol logic</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD WIDTH="30">
<img HSPACE="0" VSPACE="0" border="0" src="/images/L-circle.jpg" align="left" alt="" width="30" height="60">
</TD><TD ALIGN="Center" WIDTH=100% BGCOLOR="#000000">
<STRONG><font color="#FFFFFF" size="5"><A HREF=/docs/POE/Wheel.html>POE::Wheel</A> - high-level protocol logic</font></STRONG></TD><TD>
<img HSPACE="0" VSPACE="0" border="0" src="/images/R-circle.jpg" align="right" alt="" width="30" height="60">
</TD></TR></TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#common public wheel methods">COMMON PUBLIC WHEEL METHODS</A></LI>
	<LI><A HREF="#i/o wheel common methods">I/O WHEEL COMMON METHODS</A></LI>
	<LI><A HREF="#static functions">STATIC FUNCTIONS</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P><A HREF=/docs/POE/Wheel.html>POE::Wheel</A> - high-level protocol logic</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
  $wheel = POE::Wheel::Something-&gt;new( ... );
  $wheel-&gt;put($some_logical_data_chunks);</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>Wheels are bundles of states which perform common tasks.
Wheel::FollowTail, for example, contains I/O states for watching a
file as it grows and reading the new information when it appears.</P>
<P>Unlike Components, Wheels do not stand alone.  Each wheel must be
created by a session, and each belongs to their parent session until
it's destroyed.</P>
<P>
<HR>
<H1><A NAME="common public wheel methods">COMMON PUBLIC WHEEL METHODS</A></H1>
<P>These methods are the generic Wheel interface, and every filter must
implement them.</P>
<DL>
<DT><STRONG><A NAME="item_new_LOTS_OF_STUFF">new LOTS_OF_STUFF</A></STRONG><BR>
<DD>
<CODE>new()</CODE> creates a new wheel, returning the wheels reference.  The new
wheel will continue to run for as long as it exists.  Every wheel has
a different purpose and requires different parameters, so
LOTS_OF_STUFF will vary from one to the next.
<P></P>
<DT><STRONG><A NAME="item_DESTROY">DESTROY</A></STRONG><BR>
<DD>
Perl calls DESTROY when the wheel's last reference is relinquished.
This triggers the wheel's destruction, which stops the wheel and
releases whatever resources it was managing.
<P></P>
<DT><STRONG><A NAME="item_event_TYPE_%3D%3E_EVENT_NAME%2C_%2E%2E%2E">event TYPE =&gt; EVENT_NAME, ...</A></STRONG><BR>
<DD>
<CODE>event()</CODE> changes the events that a wheel will emit.  Its parameters are
pairs of event TYPEs and the EVENT_NAMEs to emit when each type of
event occurs.
<P>Event TYPEs differ for each wheel, and their manpages discuss them in
greater detail.  STATE_NAMEs may be undef, in which case a wheel will
stop emitting an event for that TYPE.</P>
<P>This example changes the events to emit on new input and when output
is flushed.  It stops the wheel from emitting events when errors
occur.</P>
<PRE>
  $wheel-&gt;event( InputState   =&gt; 'new_input_state',
                 ErrorState   =&gt; undef,
                 FlushedState =&gt; 'new_flushed_state',
               );</PRE>
<P></P></DL>
<P>
<HR>
<H1><A NAME="i/o wheel common methods">I/O WHEEL COMMON METHODS</A></H1>
<P>These methods are common to I/O wheels.  Some I/O wheels are read-only
and will not have a <A HREF="#item_put"><CODE>put()</CODE></A> method.</P>
<DL>
<DT><STRONG><A NAME="item_put">put LIST</A></STRONG><BR>
<DD>
<A HREF="#item_put"><CODE>put()</CODE></A> sends a LIST of one or more records to the wheel for
transmitting.  Each thing in the LIST is serialized by the wheel's
Filter, and then buffered in the wheel's Driver until it can be
flushed to its filehandle.
<P></P></DL>
<P>
<HR>
<H1><A NAME="static functions">STATIC FUNCTIONS</A></H1>
<P>These functions keep global information about all weels.  They should
be called as normal functions:</P>
<PRE>
  &amp;POE::Wheel::function( ... );</PRE>
<DL>
<DT><STRONG><A NAME="item_allocate_wheel_id">allocate_wheel_id</A></STRONG><BR>
<DD>
<A HREF="#item_allocate_wheel_id"><CODE>allocate_wheel_id()</CODE></A> allocates a uniquely identifier for a wheel.
Wheels pass these identifiers back to sessions in their events so that
sessions with several wheels can match events back to other
information.
<P><A HREF=/docs/POE/Wheel.html>POE::Wheel</A> keeps track of allocated IDs to avoid collisions.  It's
important to free an ID when it's not in use, or they will consume
memory unnecessarily.</P>
<P></P>
<DT><STRONG><A NAME="item_free_wheel_id_WHEEL_ID">free_wheel_id WHEEL_ID</A></STRONG><BR>
<DD>
Deallocates a wheel identifier so it may be reused later.  This often
is called from a wheel's destructor.
<P></P></DL>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P>The <A HREF=/docs/POE.html#see also>SEE ALSO section in <EM>POE</EM></A> contains a table of contents covering
the entire POE distribution.</P>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P>It would be nice if wheels were more like proper Unix streams.</P>
<P>
<HR>
<H1><A NAME="authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></H1>
<P>Please <A HREF=/docs/POE.html>see <EM>POE</EM></A> for more information about authors and contributors.</P>

</BODY>

</HTML>
