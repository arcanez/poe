<HTML>
<HEAD>
<TITLE><A HREF=/docs/POE/Preprocessor.html>POE::Preprocessor</A> - a macro/const/enum preprocessor</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD WIDTH="30">
<img HSPACE="0" VSPACE="0" border="0" src="/images/L-circle.jpg" align="left" alt="" width="30" height="60">
</TD><TD ALIGN="Center" WIDTH=100% BGCOLOR="#000000">
<STRONG><font color="#FFFFFF" size="5"><A HREF=/docs/POE/Preprocessor.html>POE::Preprocessor</A> - a macro/const/enum preprocessor</font></STRONG></TD><TD>
<img HSPACE="0" VSPACE="0" border="0" src="/images/R-circle.jpg" align="right" alt="" width="30" height="60">
</TD></TR></TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<UL>

		<LI><A HREF="#macros">Macros</A></LI>
		<LI><A HREF="#constants and enumerations">Constants and Enumerations</A></LI>
		<LI><A HREF="#conditional code inclusion (#ifdef)">Conditional Code Inclusion (#ifdef)</A></LI>
	</UL>

	<LI><A HREF="#debugging">DEBUGGING</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
	<LI><A HREF="#author & copyright">AUTHOR &amp; COPYRIGHT</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P><A HREF=/docs/POE/Preprocessor.html>POE::Preprocessor</A> - a macro/const/enum preprocessor</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
  use <A HREF=/docs/POE/Preprocessor.html>POE::Preprocessor</A>;</PRE>
<PRE>
  macro max (one,two) {
    ((one) &gt; (two) ? (one) : (two))
  }</PRE>
<PRE>
  print {% max $one, $two %}, &quot;\n&quot;;</PRE>
<PRE>
  const PI 3.14159265359</PRE>
<PRE>
  print &quot;PI\n&quot;;  # Substitutions don't grok Perl!</PRE>
<PRE>
  enum ZERO ONE TWO
  enum 12 TWELVE THIRTEEN FOURTEEN
  enum + FIFTEEN SIXTEEN SEVENTEEN</PRE>
<PRE>
  print &quot;ZERO ONE TWO TWELVE THIRTEEN FOURTEEN FIFTEEN SIXTEEN SEVENTEEN\n&quot;;</PRE>
<PRE>
  if ($expression) {      # include
     ... lines of code ...
  }                       # include</PRE>
<PRE>
  unless ($expression) {  # include
    ... lines of code ...
  } elsif ($expression) { # include
    ... lines of code ...
  } else {                # include
    ... lines of code ...
  }                       # include</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P><A HREF=/docs/POE/Preprocessor.html>POE::Preprocessor</A> is a Perl source filter that implements a simple
macro substitution language.  Think of it like compile-time code
templates.</P>
<P>
<H2><A NAME="macros">Macros</A></H2>
<P>Macros are defined with the <CODE>macro</CODE> statement.  The syntax is similar
to Perl subs:</P>
<PRE>
  macro macro_name (parameter_0, parameter_1) {
    macro code ... parameter_0 ... parameter_1 ...
  }</PRE>
<P>The open brace is required to be on the same line as the <CODE>macro</CODE>
statement.  The Preprocessor doesn't analyze macro bodies.  Instead,
it assumes that any closing brace in the leftmost column ends an open
macro.</P>
<P>The parameter list is optional for macros that don't accept
parameters.</P>
<PRE>
  macro macro_name {
    macro code;
  }</PRE>
<P>Macros are substituted into a program with a syntax borrowed from
Iaijutsu and altered slightly to jive with Perl's native syntax.</P>
<PRE>
  {% macro_name $param_1, 'param two' %}</PRE>
<P>This is the code the first macro would generate:</P>
<PRE>
  macro code ... $param_1 ... 'param two' ...</PRE>
<P>It's very simplistic.  See <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> for extensive macro use.</P>
<P>
<H2><A NAME="constants and enumerations">Constants and Enumerations</A></H2>
<P>The <CODE>const</CODE> command defines a constant.</P>
<PRE>
  const CONSTANT_NAME    'constant value'
  const ANOTHER_CONSTANT 23</PRE>
<P>Enumerations are defined with the <CODE>emun</CODE> command.  Enumerations start
from zero by default:</P>
<PRE>
  enum ZEROTH FIRST SECOND ...</PRE>
<P>If the first parameter of an enumeration is a number, then the
enumerated constants will start with that value:</P>
<PRE>
  enum 10 TENTH ELEVENTH TWELFTH</PRE>
<P><CODE>enum</CODE> statements may not span lines.  If the first enumeration
parameter is a plus sign, the constants will start where a previous
<CODE>enum</CODE> left off.</P>
<PRE>
  enum 13 THIRTEENTH FOURTEENTH  FIFTEENTH
  enum +  SIXTEENTH  SEVENTEENTH EIGHTEENTH</PRE>
<P>
<H2><A NAME="conditional code inclusion (#ifdef)">Conditional Code Inclusion (#ifdef)</A></H2>
<P>The preprocessor supports something like cpp's #if/#else/#endif by
usurping a bit of Perl's conditional syntax.  The following
conditional statements will be evaluated at compile time if they are
followed by the comment <CODE># include</CODE>:</P>
<PRE>
  if (EXPRESSION) {      # include
    BLOCK;
  } elsif (EXPRESSION) { # include
    BLOCK;
  } else {               # include
    BLOCK;
  }                      # include</PRE>
<PRE>
  unless (EXPRESSION) {  # include
    BLOCK;
  }                      # include</PRE>
<P>The code in each conditional statement's BLOCK will be included or
excluded in the compiled code depending on the outcome of its
EXPRESSION.</P>
<P>Conditional includes are nestable, but else and elsif must be on the
same line as the previous block's closing brace, as they are in the
previous example.</P>
<P>Conditional includes are experimental pending a decision on how useful
they are.</P>
<P>
<HR>
<H1><A NAME="debugging">DEBUGGING</A></H1>
<P><A HREF=/docs/POE/Preprocessor.html>POE::Preprocessor</A> has three debugging constants which may be defined
before the first time <A HREF=/docs/POE/Preprocessor.html>POE::Preprocessor</A> is used.</P>
<P>To trace source filtering in general, and to see the resulting code
and operations performed on each line:</P>
<PRE>
  sub POE::Preprocessor::DEBUG () { 1 }</PRE>
<P>To trace macro invocations as they happen:</P>
<PRE>
  sub POE::Preprocessor::DEBUG_INVOKE () { 1 }</PRE>
<P>To see macro, constant, and enum definitions:</P>
<PRE>
  sub POE::Preprocessor::DEBUG_DEFINE () { 1 }</PRE>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P>Source filters are line-based, and so is the macro language.  The only
constructs that may span lines are macro definitions, and those *must*
span lines.</P>
<P>The regular expressions that detect and replace code are simplistic
and may not do the right things when given challenging Perl syntax to
parse.  For example, constants are replaced within strings.</P>
<P>Substitution is done in two phases: macros first, then constants.  It
would be nicer (and more dangerous) if the phases looped around and
around until no more substitutions occurred.</P>
<P>The regexp builder makes silly subexpressions like /(?:|m)/.  That
could be done better as /m?/ or /(?:jklm)?/ if the literal is longer
than a single character.</P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P>The regexp optimizer is based on code in Ilya Zakharevich's
Text::Trie.</P>
<P>
<HR>
<H1><A NAME="author & copyright">AUTHOR &amp; COPYRIGHT</A></H1>
<P><A HREF=/docs/POE/Preprocessor.html>POE::Preprocessor</A> is Copyright 2000 Rocco Caputo.  All rights
reserved.  <A HREF=/docs/POE/Preprocessor.html>POE::Preprocessor</A> is free software; you may redistribute it
and/or modify it under the same terms as Perl itself.</P>

</BODY>

</HTML>
