<HTML>
<HEAD>
<TITLE><A HREF=/docs/POE/NFA.html>POE::NFA</A> - even driven nondeterministic finite automaton</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD WIDTH="30">
<img HSPACE="0" VSPACE="0" border="0" src="/images/L-circle.jpg" align="left" alt="" width="30" height="60">
</TD><TD ALIGN="Center" WIDTH=100% BGCOLOR="#000000">
<STRONG><font color="#FFFFFF" size="5"><A HREF=/docs/POE/NFA.html>POE::NFA</A> - even driven nondeterministic finite automaton</font></STRONG></TD><TD>
<img HSPACE="0" VSPACE="0" border="0" src="/images/R-circle.jpg" align="right" alt="" width="30" height="60">
</TD></TR></TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#public methods">PUBLIC METHODS</A></LI>
	<LI><A HREF="#predefined event fields">PREDEFINED EVENT FIELDS</A></LI>
	<LI><A HREF="#predefined event names">PREDEFINED EVENT NAMES</A></LI>
	<LI><A HREF="#miscellaneous concepts">MISCELLANEOUS CONCEPTS</A></LI>
	<UL>

		<LI><A HREF="#states' return values">States' Return Values</A></LI>
		<LI><A HREF="#resource tracking">Resource Tracking</A></LI>
		<LI><A HREF="#synchronous and asynchronous events">Synchronous and Asynchronous Events</A></LI>
		<LI><A HREF="#postbacks">Postbacks</A></LI>
		<LI><A HREF="#job control and family values">Job Control and Family Values</A></LI>
	</UL>

	<LI><A HREF="#see also">SEE ALSO</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P><A HREF=/docs/POE/NFA.html>POE::NFA</A> - even driven nondeterministic finite automaton</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
  # Import <A HREF=/docs/POE/NFA.html>POE::NFA</A> constants.
  use <A HREF=/docs/POE/NFA.html>POE::NFA</A>;</PRE>
<PRE>
  # Define a machine's states, each state's events, and the coderefs
  # that handle each event.
  my %states =
    ( start =&gt;
      { event_one =&gt; \&amp;handler_one,
        event_two =&gt; \&amp;handler_two,
        ...,
      },
      other_state =&gt;
      { event_n          =&gt; \&amp;handler_n,
        event_n_plus_one =&gt; \&amp;handler_n_plus_one,
        ...,
      },
      ...,
    );</PRE>
<PRE>
  # Spawn an NFA and enter its initial state.
  <A HREF=/docs/POE/NFA.html>POE::NFA</A>-&gt;spawn( inline_states =&gt; \%states
                 )-&gt;goto_state( $start_state, $start_event );</PRE>
<PRE>
  # Move to a new state.
  $machine-&gt;goto_state( $new_state, $new_event, @args );</PRE>
<PRE>
  # Put the current state on a stack, and move to a new one.
  $machine-&gt;call_state( $return_event, $new_state, $new_event, @args );</PRE>
<PRE>
  # Move to the previous state on the call stack.
  $machine-&gt;return_state( @returns );</PRE>
<PRE>
  # Forcibly stop a machine.
  $machine-&gt;stop();</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P><A HREF=/docs/POE/NFA.html>POE::NFA</A> combines a runtime context with an event driven
nondeterministic finite state machine.  Its main difference from
<A HREF=/docs/POE/Session.html>POE::Session</A> is that it can embody many different states, and each
state has a separate group of event handlers.  Events are delivered to
the appropriate handlers in the current state only, and moving to a
new state is an inexpensive way to change what happens when an event
arrives.</P>
<P>This manpage only discusses <A HREF=/docs/POE/NFA.html>POE::NFA</A>'s differences from <A HREF=/docs/POE/Session.html>POE::Session</A>.
It assumes a familiarity with Session's manpage, and it will refer
there whenever possible.</P>
<P>
<HR>
<H1><A NAME="public methods">PUBLIC METHODS</A></H1>
<P>See <A HREF=/docs/POE/Session.html>POE::Session</A>'s documentation.</P>
<DL>
<DT><STRONG><A NAME="item_ID">ID</A></STRONG><BR>
<DD>
See <A HREF=/docs/POE/Session.html>POE::Session</A>.
<P></P>
<DT><STRONG><A NAME="item_create">create</A></STRONG><BR>
<DD>
<A HREF=/docs/POE/NFA.html>POE::NFA</A> does not have a <A HREF="#item_create"><CODE>create()</CODE></A> constructor.
<P></P>
<DT><STRONG><A NAME="item_get_current_state">get_current_state</A></STRONG><BR>
<DD>
<A HREF="#item_get_current_state"><CODE>get_current_state()</CODE></A> returns the name of the machine's current
state.  This method is mainly used for getting the state of some other
machine.  In the machine's own event handlers, it's easier to just
access <CODE>$_[STATE]</CODE>.
<P></P>
<DT><STRONG><A NAME="item_new">new</A></STRONG><BR>
<DD>
<A HREF=/docs/POE/NFA.html>POE::NFA</A> does not have a <A HREF="#item_new"><CODE>new()</CODE></A> constructor.
<P></P>
<DT><STRONG><A NAME="item_spawn_STATE_NAME_%3D%3E_HANDLERS_HASHREF%2C_%2E%2E">spawn STATE_NAME =&gt; HANDLERS_HASHREF, ...</A></STRONG><BR>
<DD>
<CODE>spawn()</CODE> is <A HREF=/docs/POE/NFA.html>POE::NFA</A>'s session constructor.  It reflects the idea
that new state machines are spawned like threads or processes.  The
machine itself is defined as a list of state names and hashrefs
mapping events to handlers within each state.
<PRE>
  my %machine =
    ( state_1 =&gt;
      { event_1 =&gt; \&amp;handler_1,
        event_2 =&gt; \&amp;handler_2,
      },
      state_2 =&gt;
      { event_1 =&gt; \&amp;handler_3,
        event_2 =&gt; \&amp;handler_4,
      },
    );</PRE>
<P>Each state may define the same states.  The proper handler will be
called depending on the machine's current state.  For example, if
<CODE>event_1</CODE> is dispatched while the previous machine is in <CODE>state_2</CODE>,
then <CODE>&amp;handler_3</CODE> is called to handle the event.  It happens because
the state -&gt; event -&gt; handler map looks like this:</P>
<PRE>
  $machine{state_2}-&gt;{event_1} = \&amp;handler_3;</PRE>
<P>The <CODE>spawn()</CODE> method currently only accepts <CODE>inline_states</CODE> and
<CODE>options</CODE>.  Others will be added as necessary.</P>
<P></P>
<DT><STRONG><A NAME="item_option">option</A></STRONG><BR>
<DD>
See <A HREF=/docs/POE/Session.html>POE::Session</A>.
<P></P>
<DT><STRONG><A NAME="item_postback">postback</A></STRONG><BR>
<DD>
See <A HREF=/docs/POE/Session.html>POE::Session</A>.
<P></P>
<DT><STRONG><A NAME="item_goto_state_NEW_STATE">goto_state NEW_STATE</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_goto_state_NEW_STATE%2C_ENTRY_EVENT">goto_state NEW_STATE, ENTRY_EVENT</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_goto_state_NEW_STATE%2C_ENTRY_EVENT%2C_EVENT_ARGS">goto_state NEW_STATE, ENTRY_EVENT, EVENT_ARGS</A></STRONG><BR>
<DD>
<CODE>goto_state</CODE> puts the machine into a new state.  If an ENTRY_EVENT is
specified, then that event will be dispatched when the machine enters
the new state.  EVENT_ARGS, if included, will be passed to the entry
event's handler via <CODE>ARG0..$#_</CODE>.
<PRE>
  my $machine = $_[MACHINE];
  $machine-&gt;goto_state( 'next_state' );
  $machine-&gt;goto_state( 'next_state', 'call_this_event' );
  $machine-&gt;goto_state( 'next_state', 'call_this_event', @with_these_args );</PRE>
<P></P>
<DT><STRONG><A NAME="item_stop">stop</A></STRONG><BR>
<DD>
<A HREF="#item_stop"><CODE>stop()</CODE></A> forces a machine to stop.  It's similar to posting <CODE>_stop</CODE>
to the machine, but it performs some extra NFA cleanup.  The machine
will also stop gracefully if it runs out of things to do, just like
<A HREF=/docs/POE/Session.html>POE::Session</A>.
<P><A HREF="#item_stop"><CODE>stop()</CODE></A> is heavy-handed.  It will force resource cleanup.  Circular
references in the machine's <A HREF="#item_RUNSTATE"><CODE>RUNSTATE</CODE></A> are not POE's responsibility
and may cause memory leaks.</P>
<PRE>
  $_[MACHINE]-&gt;stop();</PRE>
<P></P>
<DT><STRONG><A NAME="item_call_state_RETURN_EVENT%2C_NEW_STATE">call_state RETURN_EVENT, NEW_STATE</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_call_state_RETURN_EVENT%2C_NEW_STATE%2C_ENTRY_EVEN">call_state RETURN_EVENT, NEW_STATE, ENTRY_EVENT</A></STRONG><BR>
<DD>
<DT><STRONG>call_state RETURN_EVENT, NEW_STATE, ENTRY_EVENT, EVENT_ARGS</STRONG><BR>
<DD>
<CODE>call_state()</CODE> is similar to <CODE>goto_state()</CODE>, but it pushes the
current state on a stack.  At some point a <A HREF="#item_return_state"><CODE>return_state()</CODE></A> call will
pop the saved state and cause the machine to return there.
<P><CODE>call_state()</CODE> accepts one parameter different from <CODE>goto_state()</CODE>,
and that is <CODE>RETURN_EVENT</CODE>.  <CODE>RETURN_EVENT</CODE> specifies the event to
emit when the machine returns to the calling state.  That is, the
called state returns to the caller's <CODE>RETURN_EVENT</CODE> handler.  The
<CODE>RETURN_EVENT</CODE> handler receives <CODE>return_states()</CODE>'s <CODE>RETURN_ARGS</CODE>
via <CODE>ARG0..$#_</CODE>.</P>
<PRE>
  $machine-&gt;call_state( 'return_here', 'new_state', 'entry_event' );</PRE>
<P>As with <CODE>goto_state()</CODE>, <CODE>ENTRY_EVENT</CODE> is the event that will be
emitted once the machine enters its new state.  <CODE>ENTRY_ARGS</CODE> are
parameters passed to the <CODE>ENTRY_EVENT</CODE> handler via <CODE>ARG0..$#_</CODE>.</P>
<P></P>
<DT><STRONG><A NAME="item_return_state">return_state</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_return_state_RETURN_ARGS">return_state RETURN_ARGS</A></STRONG><BR>
<DD>
<A HREF="#item_return_state"><CODE>return_state()</CODE></A> returns to the most recent state which called
<CODE>call_state()</CODE>, optionally invoking the calling state's
<CODE>RETURN_EVENT</CODE>, possibly with <CODE>RETURN_ARGS</CODE> passed to it via
<CODE>ARG0..$#_</CODE>.
<PRE>
  $_[MACHINE]-&gt;return_state( );
  $_[MACHINE]-&gt;return_state( 'success', $success_value );</PRE>
<P></P></DL>
<P>
<HR>
<H1><A NAME="predefined event fields">PREDEFINED EVENT FIELDS</A></H1>
<P><A HREF=/docs/POE/NFA.html>POE::NFA</A>'s predefined event fields are the same as <A HREF=/docs/POE/Session.html>POE::Session</A>'s with
the following three exceptions.</P>
<DL>
<DT><STRONG><A NAME="item_MACHINE">MACHINE</A></STRONG><BR>
<DD>
<A HREF="#item_MACHINE"><CODE>MACHINE</CODE></A> is equivalent to Session's <CODE>SESSION</CODE> field.  It hold a
reference to the current state machine, and it's useful for calling
methods on it.  See <A HREF=/docs/POE/Session.html>POE::Session</A>'s <CODE>SESSION</CODE> field for more
information.
<PRE>
  $_[MACHINE]-&gt;goto_state( $next_state, $next_state_entry_event );</PRE>
<P></P>
<DT><STRONG><A NAME="item_RUNSTATE">RUNSTATE</A></STRONG><BR>
<DD>
<A HREF="#item_RUNSTATE"><CODE>RUNSTATE</CODE></A> is equivalent to Session's <CODE>HEAP</CODE> field.  It holds an
anoymous hash reference which POE is guaranteed not to touch.  See
<A HREF=/docs/POE/Session.html>POE::Session</A>'s <CODE>HEAP</CODE> field for more information.
<P></P>
<DT><STRONG><A NAME="item_STATE">STATE</A></STRONG><BR>
<DD>
<A HREF="#item_STATE"><CODE>STATE</CODE></A> contains the name of the machine's current state.  It is not
equivalent to anything from <A HREF=/docs/POE/Session.html>POE::Session</A>.
<P></P>
<DT><STRONG><A NAME="item_EVENT">EVENT</A></STRONG><BR>
<DD>
<A HREF="#item_EVENT"><CODE>EVENT</CODE></A> is equivalent to Session's <A HREF="#item_STATE"><CODE>STATE</CODE></A> field.  It holds the name
of the event which invoked the current handler.  See <A HREF=/docs/POE/Session.html>POE::Session</A>'s
<A HREF="#item_STATE"><CODE>STATE</CODE></A> field for more information.
<P></P></DL>
<P>
<HR>
<H1><A NAME="predefined event names">PREDEFINED EVENT NAMES</A></H1>
<P><A HREF=/docs/POE/NFA.html>POE::NFA</A> defines four events of its own.  See <A HREF=/docs/POE/Session.html>POE::Session</A>'s
``PREDEFINED EVENT NAMES'' section for more information about other
predefined events.</P>
<DL>
<DT><STRONG><A NAME="item_poe_nfa_goto_state">poe_nfa_goto_state</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_poe_nfa_pop_state">poe_nfa_pop_state</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_poe_nfa_push_state">poe_nfa_push_state</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_poe_nfa_stop">poe_nfa_stop</A></STRONG><BR>
<DD>
<A HREF=/docs/POE/NFA.html>POE::NFA</A> uses these states internally to manage state transitions and
stopping the machine in an orderly fashion.  There may be others in
the future, and they will all follow the /^poe_nfa_/ naming
convention.  To avoid conflicts, please don't define events beginning
with ``poe_nfa_''.
<P></P></DL>
<P>
<HR>
<H1><A NAME="miscellaneous concepts">MISCELLANEOUS CONCEPTS</A></H1>
<P>
<H2><A NAME="states' return values">States' Return Values</A></H2>
<P>See <A HREF=/docs/POE/Session.html>POE::Session</A>.</P>
<P>
<H2><A NAME="resource tracking">Resource Tracking</A></H2>
<P>See <A HREF=/docs/POE/Session.html>POE::Session</A>.</P>
<P>
<H2><A NAME="synchronous and asynchronous events">Synchronous and Asynchronous Events</A></H2>
<P>See <A HREF=/docs/POE/Session.html>POE::Session</A>.</P>
<P>
<H2><A NAME="postbacks">Postbacks</A></H2>
<P>See <A HREF=/docs/POE/Session.html>POE::Session</A>.</P>
<P>
<H2><A NAME="job control and family values">Job Control and Family Values</A></H2>
<P>See <A HREF=/docs/POE/Session.html>POE::Session</A>.</P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P>Many of <A HREF=/docs/POE/NFA.html>POE::NFA</A>'s features are taken directly from <A HREF=/docs/POE/Session.html>POE::Session</A>.
Please see <A HREF="/POE/Session.html">the <A HREF=/docs/POE/Session.html>POE::Session</A> manpage</A> for more information.</P>
<P>The <A HREF=/docs/POE.html#see also>SEE ALSO section in <EM>POE</EM></A> contains a table of contents covering
the entire POE distribution.</P>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P>See <A HREF=/docs/POE/Session.html>POE::Session</A>'s documentation.</P>
<P>Object and package states aren't implemented.  Some other stuff is
just lashed together with twine.  <A HREF=/docs/POE/NFA.html>POE::NFA</A> needs some more work.</P>
<P>
<HR>
<H1><A NAME="authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></H1>
<P>Please <A HREF=/docs/POE.html>see <EM>POE</EM></A> for more information about authors and contributors.</P>

</BODY>

</HTML>
