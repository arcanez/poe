<HTML>
<HEAD>
<TITLE><A HREF=/docs/POE/Session.html>POE::Session</A> - an event driven abstract state machine</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD WIDTH="30">
<img HSPACE="0" VSPACE="0" border="0" src="/images/L-circle.jpg" align="left" alt="" width="30" height="60">
</TD><TD ALIGN="Center" WIDTH=100% BGCOLOR="#000000">
<STRONG><font color="#FFFFFF" size="5"><A HREF=/docs/POE/Session.html>POE::Session</A> - an event driven abstract state machine</font></STRONG></TD><TD>
<img HSPACE="0" VSPACE="0" border="0" src="/images/R-circle.jpg" align="right" alt="" width="30" height="60">
</TD></TR></TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#public methods">PUBLIC METHODS</A></LI>
	<LI><A HREF="#predefined event fields">PREDEFINED EVENT FIELDS</A></LI>
	<LI><A HREF="#predefined event names">PREDEFINED EVENT NAMES</A></LI>
	<LI><A HREF="#miscellaneous concepts">MISCELLANEOUS CONCEPTS</A></LI>
	<UL>

		<LI><A HREF="#states' return values">States' Return Values</A></LI>
		<LI><A HREF="#resource tracking">Resource Tracking</A></LI>
		<LI><A HREF="#synchronous and asynchronous events">Synchronous and Asynchronous Events</A></LI>
		<LI><A HREF="#postbacks">Postbacks</A></LI>
		<LI><A HREF="#job control and family values">Job Control and Family Values</A></LI>
	</UL>

	<LI><A HREF="#see also">SEE ALSO</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P><A HREF=/docs/POE/Session.html>POE::Session</A> - an event driven abstract state machine</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
  # Import <A HREF=/docs/POE/Session.html>POE::Session</A> constants.
  use <A HREF=/docs/POE/Session.html>POE::Session</A>;</PRE>
<PRE>
  # The older, more DWIMmy constructor.
  <A HREF=/docs/POE/Session.html>POE::Session</A>-&gt;new(</PRE>
<PRE>
    # Inline or coderef states.
    state_one =&gt; \&amp;coderef_one,
    state_two =&gt; sub { ... },</PRE>
<PRE>
    # Plain object and package states.
    $object_one  =&gt; [ 'state_three', 'state_four',  'state_five'  ],
    $package_one =&gt; [ 'state_six',   'state_seven', 'state_eight' ],</PRE>
<PRE>
    # Mapped object and package states.
    $object_two  =&gt; { state_nine =&gt; 'method_nine', ... },
    $package_two =&gt; { state_ten  =&gt; 'method_ten', ... },</PRE>
<PRE>
    # Parameters for the session's initial state.
    \@start_args,
  );</PRE>
<PRE>
  # The newer, more explicit and safer constructor.
  <A HREF=/docs/POE/Session.html>POE::Session</A>-&gt;create(</PRE>
<PRE>
    # Inline or coderef states.
    inline_states =&gt;
      { state_one =&gt; \&amp;coderef_one,
        state_two =&gt; sub { ... },
      },</PRE>
<PRE>
    # Plain and mapped object states.
    object_states =&gt;
    [ $object_one =&gt; [ 'state_three', 'state_four', 'state_five' ],
      $object_two =&gt; { state_nine =&gt; 'method_nine' },
    ],</PRE>
<PRE>
    # Plain and mapped package states.
    package_states =&gt;
    [ $package_one =&gt; [ 'state_six', 'state_seven', 'state_eight' },
      $package_two =&gt; { state_ten =&gt; 'method_ten' },
    ],</PRE>
<PRE>
    # Parameters for the session's initial state.
    args =&gt; [ argument_zero, argument_one, ... ],</PRE>
<PRE>
    # Initial options.  See the option() method.
    options =&gt; \%options,</PRE>
<PRE>
    # Change the session's heap representation.
    heap =&gt; [ ],
  );</PRE>
<P>Other methods:</P>
<PRE>
  # Retrieve a session's unique identifier.
  $session_id = $session-&gt;ID;</PRE>
<PRE>
  # Retrieve a reference to the session's heap.
  $session_heap = $session-&gt;get_heap();</PRE>
<PRE>
  # Set or clear session options.
  $session-&gt;option( trace =&gt; 1, default =&gt; 1 );
  $session-&gt;option( trace );</PRE>
<PRE>
  # Create a postback, then invoke it and pass back additional
  # information.
  $postback_coderef = $session-&gt;postback( $state_name, @state_args );
  &amp;{ $postback_coderef }( @additional_args );</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P><A HREF=/docs/POE/Session.html>POE::Session</A> combines a runtime context with an event driven state
machine.  Together they implement a simple cooperatively timesliced
thread.</P>
<P>Sessions receive their timeslices as events from <A HREF=/docs/POE/Kernel.html>POE::Kernel</A>.  Each
event has two fields, a state name and a session identifier.  These
fields describe the code to run and the context to run it in,
respectively.  Events carry several other fields which will be
discussed in the ``Predefined Event Fields'' section.</P>
<P>States are re-entrant since they are invoked with their runtime
contexts.  Although it's not usually necessary, this re-entrancy
allows a single function to be bound to several different sessions,
under several different state names.</P>
<P>As sessions run, they post new events through the Kernel.  These
events may be for themselves or other sessions, in which case they act
as a form of inter-session communications.  The Kernel can also
generate events based on external conditions such as file activity or
the passage of time.</P>
<P>POE provides some convenient built-in states with special meanings.
They will be covered later on in the ``Predefined States'' section.</P>
<P>
<HR>
<H1><A NAME="public methods">PUBLIC METHODS</A></H1>
<DL>
<DT><STRONG><A NAME="item_ID">ID</A></STRONG><BR>
<DD>
<A HREF="#item_ID"><CODE>ID()</CODE></A> returns the session instance's unique identifier.  This is a
number that starts with 1 and counts up forever, or until something
causes the number to wrap.  It's theoretically possible that session
IDs may collide after about 4.29 billion sessions have been created.
<P></P>
<DT><STRONG><A NAME="item_create_LOTS_OF_STUFF">create LOTS_OF_STUFF</A></STRONG><BR>
<DD>
<CODE>create()</CODE> is the recommended Session constructor.  It binds states to
their corresponding event names, initalizes other parts of the
session, and then fires off its <A HREF="#item__start"><CODE>_start</CODE></A> state, possibly with some
parameters.
<P>create's parameters look like a hash of name/value pairs, but it's
really just a list.  <CODE>create()</CODE> is preferred over the older, more DWIMmy
<CODE>new()</CODE> constructor because each kind of parameter is explicitly named.
This makes it easier for maintainers to understand the constructor
call, and it lets the constructor unambiguously recognize and validate
parameters.</P>
<DL>
<DT><STRONG><A NAME="item_args_%3D%3E_LISTREF">args =&gt; LISTREF</A></STRONG><BR>
<DD>
The <CODE>args</CODE> parameter accepts a reference to a list of parameters that
will be passed to the machine's <A HREF="#item__start"><CODE>_start</CODE></A> state.  They are passed in
the <A HREF="#item__start"><CODE>_start</CODE></A> event's <CODE>ARG0..$#_</CODE> fields.
<PRE>
  args =&gt; [ 'arg0', 'arg1', 'etc.' ],</PRE>
<PRE>
  sub _start {
    my @args = @_[ARG0..#$_];
    print &quot;I received these parameters from create()'s args: @args\n&quot;;
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_heap_%3D%3E_ANYTHING">heap =&gt; ANYTHING</A></STRONG><BR>
<DD>
The <CODE>heap</CODE> parameter defines a session's heap.  The heap is passed
into states as the $_[HEAP] field.  Heaps are anonymous hash
references by default.
<PRE>
  <A HREF=/docs/POE/Session.html>POE::Session</A>-&gt;create( ..., heap =&gt; { runstate_variable =&gt; 1 }, ... );</PRE>
<PRE>
  sub state_function {
    my $heap = $_[HEAP];
    print &quot;runstate variable is $heap-&gt;{runstate_variable}\n&quot;;
  }</PRE>
<P>It's also possible to use create's <CODE>heap</CODE> parameter to change the
heap into something completely different, such as a list reference or
even an object.</P>
<PRE>
  sub RUNSTATE_VARIABLE () { 0 } # offset into the heap
  <A HREF=/docs/POE/Session.html>POE::Session</A>-&gt;create( ..., heap =&gt; [ 1 ], ... );</PRE>
<PRE>
  sub state_function {
    my $heap = $_[HEAP];
    print &quot;runstate variable is &quot;, $heap-&gt;[RUNSTATE_VARIABLE], &quot;\n&quot;;
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_inline_states_%3D%3E_HASHREF">inline_states =&gt; HASHREF</A></STRONG><BR>
<DD>
<CODE>inline_states</CODE> maps events names to the plain coderefs which will
handle them.  Its value is a reference to a hash of event names and
corresponding coderefs.
<PRE>
  inline_states =&gt;
  { _start =&gt; sub { print &quot;arg0=$_[ARG0], arg1=$_[ARG1], etc.=$_[ARG2]\n&quot;; }
    _stop  =&gt; \&amp;stop_handler,
  },</PRE>
<P>These states are called ``inline'' because they can be inline anonymous
subs.</P>
<P></P>
<DT><STRONG><A NAME="item_object_states_%3D%3E_LISTREF">object_states =&gt; LISTREF</A></STRONG><BR>
<DD>
<CODE>object_states</CODE> maps event names to the object methods which will
handle them.  Its value is a <STRONG>listref</STRONG> of object references and the
methods to use.  It's a listref because using a hashref would
stringify its keys, and the object references would become unusable.
<P>The object's methods can be specified in two ways.</P>
<P>The first form associates a listref to each object reference.  This
form maps each event to an object method with the same name.  In this
example, <CODE>event_one</CODE> is handled by <CODE>$object</CODE>'s <CODE>event_one()</CODE>
method.</P>
<PRE>
  object_states =&gt;
  [ $object =&gt; [ 'event_one', 'event_two' ],
  ];</PRE>
<P>The second form associates a hashref to each object reference.  In
turn, the hashref maps each event name to a method in the object.  In
this form, the object's method names needn't match the event names
they'll handle.  For example, <CODE>event_four</CODE> is handled by <CODE>$object's</CODE>
<CODE>handler_four()</CODE> method.</P>
<PRE>
  object_states =&gt;
  [ $object =&gt; { event_three =&gt; 'handler_three',
                 event_four  =&gt; 'handler_four',
               }
  ];</PRE>
<P></P>
<DT><STRONG><A NAME="item_options_%3D%3E_HASHREF">options =&gt; HASHREF</A></STRONG><BR>
<DD>
<CODE>options</CODE> contains a new session's initial options.  It's equivalent
to creating the session and then calling its <CODE>option()</CODE> method to set
them.  HASHREF contains a set of option/value pairs.
<P>These two statements are equivalent:</P>
<PRE>
  <A HREF=/docs/POE/Session.html>POE::Session</A>-&gt;create(
    ...,
    options =&gt; { trace =&gt; 1, debug =&gt; 1 },
    ...,
  );</PRE>
<PRE>
  <A HREF=/docs/POE/Session.html>POE::Session</A>-&gt;create(
    ...,
  )-&gt;option( trace =&gt; 1, debug =&gt; 1 );</PRE>
<P>See the <CODE>option()</CODE> method for a list of options and values.</P>
<P></P>
<DT><STRONG><A NAME="item_package_states_%3D%3E_LISTREF">package_states =&gt; LISTREF</A></STRONG><BR>
<DD>
<CODE>package_states</CODE> maps event names to the package methods which will
handle them.  It's very similar to <CODE>object_states</CODE>.
<CODE>package_states</CODE>' value is a <STRONG>listref</STRONG> of package names and the
methods to use.  It's a listref for consistency with <CODE>object_states</CODE>.
<P>The package's methods can be specified in two ways.</P>
<P>The first form associates a listref to each package name.  This form
maps each event to a package method with the same name.  In this
example, <CODE>event_ten</CODE> is handled by <CODE>Package</CODE>'s <CODE>event_ten()</CODE>
method.</P>
<PRE>
  package_states =&gt;
  [ Package =&gt; [ 'event_ten', 'event_eleven' ],
  ];</PRE>
<P>The second form associates a hashref to each package n ame.  In turn,
the hashref maps each event name to a method in the package.  In this
form, the package's method names needn't match the event names they'll
handle.  For example, <CODE>event_twelve</CODE> is handled by <CODE>Package</CODE>'s
<CODE>handler_twelve()</CODE> method.</P>
<PRE>
  package_states =&gt;
  [ Package =&gt; { event_twelve   =&gt; 'handler_twelve',
                 event_thirteen =&gt; 'handler_thirteen',
               }
  ];</PRE>
<P></P></DL>
<DT><STRONG><A NAME="item_new_LOTS_OF_STUFF">new LOTS_OF_STUFF</A></STRONG><BR>
<DD>
<CODE>new()</CODE> is Session's older constructor.  Its design was clever at the
time, but it didn't expand well.  It's still useful for quick one-line
hacks, but consider using <CODE>create()</CODE> for more complex sessions.
<P>Inline states, object states, package states, and _start arguments are
all inferred by their contexts.  This context sensitivity makes it
harder for maintainers to understand what's going on, and it allows
errors to be interpreted as different behavior.</P>
<P>Inline states are specified as a scalar mapped to a coderef.</P>
<PRE>
  event_one =&gt; \&amp;state_one,
  event_two =&gt; sub { ... },</PRE>
<P>Object states are specified as object references mapped to list or
hash references.  Objects that are mapped to listrefs will handle
events with identically named methods.</P>
<PRE>
  $object_one =&gt; [ 'event_one', 'event_two' ],</PRE>
<P>Objects that are mapped to hashrefs can handle events with differently
named methods.</P>
<PRE>
  $object_two =&gt; { event_ten =&gt; 'method_foo', event_eleven =&gt; 'method_bar' },</PRE>
<P>Packgae states are specified as package names mapped to list or hash
references.  Package names that are mapped to listrefs will handle
events with identically named methods.</P>
<PRE>
  PackageOne =&gt; [ 'event_five', 'event_six' ],</PRE>
<P>Package names that are mapped to hashrefs can handle events with
differently named methods.</P>
<PRE>
  PackageTwo =&gt; { event_seven =&gt; 'method_baz', event_eight =&gt; 'method_quux' },</PRE>
<P>Arguments for the <A HREF="#item__start"><CODE>_start</CODE></A> state are specified as listrefs.</P>
<PRE>
  [ 'arg0', 'arg1', ... ],</PRE>
<P>So, in summary, the rules for this constructor are:</P>
<PRE>
  If a scalar appears as the &quot;key&quot; field ...
    If a coderef appears as its &quot;value&quot; ...
      Then it's an inline event handler.
    If a listref appears as its &quot;value&quot; ...
      Then it's a set of package states with the same names.
    If a hashref appears as its &quot;value&quot; ...
      Then it's a set of package states with possibly different names.
    Otherwise, it's an error.
  If an object reference appears as the &quot;key&quot; field ...
    If a listref appears as its &quot;value&quot; ...
      Then it's a set of object states with the same names.
    If a hashref appears as its &quot;value&quot; ...
      Then it's a set of object states with possibly different names.
    Otherwise, it's an error.
  If a listref appears as the &quot;key&quot; field ...
    Then it's a set of C&lt;_start&gt; arguments, and it has no &quot;value&quot;.</PRE>
<P></P>
<DT><STRONG><A NAME="item_option_OPTION_NAME">option OPTION_NAME</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_option_OPTION_NAME%2C_OPTION_VALUE">option OPTION_NAME, OPTION_VALUE</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_option_NAME_VALUE_PAIR_LIST">option NAME_VALUE_PAIR_LIST</A></STRONG><BR>
<DD>
<CODE>option()</CODE> sets and/or retrieves options' values.
<P>The first form returns the value of a single option, OPTION_NAME,
without changing it.</P>
<PRE>
  my $trace_value = $_[SESSION]-&gt;option( 'trace' );</PRE>
<P>The second form sets OPTION_NAME to OPTION_VALUE, returning the
<STRONG>previous</STRONG> value of OPTION_NAME.</P>
<PRE>
  my $old_trace_value = $_[SESSION]-&gt;option( trace =&gt; $new_trace_value );</PRE>
<P>The final form sets several options, returning a hashref containing
pairs of option names and their <STRONG>previous</STRONG> values.</P>
<PRE>
  my $old_values = $_[SESSION]-&gt;option(
    trace =&gt; $new_trace_value,
    debug =&gt; $new_debug_value,
  );
  print &quot;Old option values:\n&quot;;
  while (my ($option, $old_value) = each %$old_values) {
    print &quot;$option = $old_value\n&quot;;
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_postback_EVENT_NAME%2C_PARAMETER_LIST">postback EVENT_NAME, PARAMETER_LIST</A></STRONG><BR>
<DD>
<CODE>postback()</CODE> creates anonymous coderefs which, when called, post
EVENT_NAME events back to the session whose <CODE>postback()</CODE> method was
called.  Postbacks hold external references on the sessions they're
created for, so they keep their sessions alive.
<P>The EVENT_NAME event includes two fields, both of which are list
references.  <A HREF="#item_ARG0"><CODE>ARG0</CODE></A> contains a reference to the PARAMETER_LIST passed
to <CODE>postback()</CODE>.  This is the ``request'' field.  <A HREF="#item_ARG1"><CODE>ARG1</CODE></A> holds a
reference to the parameters passed to the coderef when it's called.
That's the ``response'' field.</P>
<P>This creates a Tk button that posts an ``ev_counters_begin'' event to
<CODE>$session</CODE> whenever it's pressed.</P>
<PRE>
  $poe_tk_main_window-&gt;Button
    ( -text    =&gt; 'Begin Slow and Fast Alarm Counters',
      -command =&gt; $session-&gt;postback( 'ev_counters_begin' )
    )-&gt;pack;</PRE>
<P><CODE>postback()</CODE> works wherever a callback does.  Another good use of
postbacks is for request/response protocols between sessions.  For
example, a client session will post an event to a server session.  The
client may include a postback as part of its request event, or the
server may build a postback based on <CODE>$_[SENDER]</CODE> and an event name
either pre-arranged or provided by the client.</P>
<P>Since <CODE>postback()</CODE> is a Session method, you can call it on
<CODE>$_[SESSION]</CODE> to create a postback for the current session.  In this
case, the client gives its postback to the server, and the server
would call the postback to return a response event.</P>
<PRE>
  # This code is in a client session.  SESSION is this session, so it
  # refers to the client.
  my $client_postback = $_[SESSION]-&gt;postback( reply_event_name =&gt; $data );</PRE>
<P>The other case is where the server creates a postback to respond to a
client.  Here, it calls <CODE>postback()</CODE> on <CODE>$_[SENDER]</CODE> to create a
postback that will respond to the request's sender.</P>
<PRE>
  # This code is in a server session.  SENDER is the session that sent
  # a request event: the client session.
  my $client_postback = $_[SENDER]-&gt;postback( reply_event_name =&gt; $data );</PRE>
<P>In the following code snippets, Servlet is a session that acts like a
tiny daemon.  It receives requests from ``client'' sessions, performs
som long-running task, and eventually posts responses back.  Client
sends requests to Servlet and eventually receives its responses.</P>
<PRE>
  # Aliases are a common way for daemon sessions to advertise
  # themselves.  They also provide convenient targets for posted
  # requests.  Part of Servlet's initialization is setting its alias.</PRE>
<PRE>
  sub Servlet::_start {
    ...;
    $_[KERNEL]-&gt;alias_set( 'server' );
  }</PRE>
<PRE>
  # This function accepts a request event.  It creates a postback
  # based on the sender's information, and it saves the postback until
  # it's ready to be used.  Postbacks keep their sessions alive, so
  # this also ensures that the client will wait for a response.</PRE>
<PRE>
  sub Servlet::accept_request_event {
    my ($heap, $sender, $reply_to, @request_args) =
      @_[HEAP, SENDER, ARG0, ARG1..$#_];</PRE>
<PRE>
    # Set the request in motion based on @request_args.  This may take
    # a while.</PRE>
<PRE>
    ...;</PRE>
<PRE>
    # Create a postback, and hold onto it so we'll have a way to
    # respond back to the client session when the request has
    # finished.</PRE>
<PRE>
    $heap-&gt;{postback}-&gt;{$sender} =
      $sender-&gt;postback( $reply_to, @request_args );
  }</PRE>
<PRE>
  # When the server is ready to respond, it retrieves the postback and
  # calls it with the response's values.  The postback acts like a
  # &quot;wormhole&quot; back to the client session.  Letting the postback fall
  # out of scope destroys it, so it will stop keeping the session
  # alive.  The response event, however, will take up where the
  # postback left off, so the client will still linger at least as
  # long as it takes to receive its response.</PRE>
<PRE>
  sub Servlet::ready_to_respond {
    my ($heap, $sender, @response_values) = @_[HEAP, ARG0, ARG1..$#_];</PRE>
<PRE>
    my $postback = delete $heap-&gt;{postback}-&gt;{$sender};
    $postback-&gt;( @response_values );
  }</PRE>
<PRE>
  # This is the client's side of the transaction.  Here it posts a
  # request to the &quot;server&quot; alias.</PRE>
<PRE>
  sub Client::request {
    my $kernel = $_[KERNEL];</PRE>
<PRE>
    # Assemble a request for the server.
    my @request = ( 1, 2, 3 );</PRE>
<PRE>
    # Post the request to the server.
    $kernel-&gt;post( server =&gt; accept_request_event =&gt; reply_to =&gt; @request );
  }</PRE>
<PRE>
  # Here's where the client receives its response.  Postback events
  # have two parameters: a request block and a response block.  Both
  # are array references containing the parameters given to the
  # postback at construction time and at use time, respectively.</PRE>
<PRE>
  sub Client::reply_to {
    my ($session, $request, $response) = @_[SESSION, ARG0, ARG1];</PRE>
<PRE>
    print &quot;Session &quot;, $session-&gt;ID, &quot; requested: @$request\n&quot;;
    print &quot;Session &quot;, $session-&gt;ID, &quot; received : @$response\n&quot;;
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_get_heap">get_heap</A></STRONG><BR>
<DD>
<A HREF="#item_get_heap"><CODE>get_heap()</CODE></A> returns a reference to a session's heap.  It's the same
value that's passed to every state via the <A HREF="#item_HEAP"><CODE>HEAP</CODE></A> field, so it's not
necessary within states.
<P>Combined with the Kernel's <CODE>get_active_session()</CODE> method,
<A HREF="#item_get_heap"><CODE>get_heap()</CODE></A> lets libraries access a Session's heap without having to
be given it.  It's convenient, for example, to write a function like
this:</P>
<PRE>
  sub put_stuff {
    my @stuff_to_put = @_;
    $poe_kernel-&gt;get_active_session()-&gt;heap()-&gt;{wheel}-&gt;put( @stuff_to_put );
  }</PRE>
<PRE>
  sub some_state {
    ...;
    &amp;put_stuff( @stuff_to_put );
  }</PRE>
<P>While it's more efficient to pass <A HREF="#item_HEAP"><CODE>HEAP</CODE></A> along, it's also less
convenient.</P>
<PRE>
  sub put_stuff {
    my ($heap, @stuff_to_put) = @_;
    $heap-&gt;{wheel}-&gt;put( @stuff_to_put );
  }</PRE>
<PRE>
  sub some_state {
    ...;
    &amp;put_stuff( $_[HEAP], @stuff_to_put );
  }</PRE>
<P>Although if you expect to have a lot of calls to &amp;put_a_wheel() in
your program, you may want to optimize for programmer efficiency by
using the first form.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="predefined event fields">PREDEFINED EVENT FIELDS</A></H1>
<P>Each session maintains its unique runtime context.  Sessions pass
their contexts on to their states through a series of standard
parameters.  These parameters tell each state about its Kernel, its
Session, itself, and the events that invoke it.</P>
<P>State parameters' offsets into @_ are never used directly.  Instead
they're referenced by symbolic constant.  This lets POE to change
their order without breaking programs, since the constants will always
be correct.</P>
<P>These are the @_ fields that make up a session's runtime context.</P>
<DL>
<DT><STRONG><A NAME="item_ARG0">ARG0</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_ARG1">ARG1</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_ARG2">ARG2</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_ARG3">ARG3</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_ARG4">ARG4</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_ARG5">ARG5</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_ARG6">ARG6</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_ARG7">ARG7</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_ARG8">ARG8</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_ARG9">ARG9</A></STRONG><BR>
<DD>
<CODE>ARG0..ARG9</CODE> are a state's first ten custom parameters.  They will
always be at the end of <CODE>@_</CODE>, so it's possible to access more than
ten parameters with <CODE>$_[ARG9+1]</CODE> or even this:
<PRE>
  my @args = @_[ARG0..$#_];</PRE>
<P>The custom parameters often correspond to PARAMETER_LIST in many of
the Kernel's methods.  This passes the words ``zero'' through ``four'' to
<CODE>some_state</CODE> as <CODE>@_[ARG0..ARG4]</CODE>:</P>
<PRE>
  $_[KERNEL]-&gt;yield( some_state =&gt; qw( zero one two three four ) );</PRE>
<P>Only <A HREF="#item_ARG0"><CODE>ARG0</CODE></A> is really needed.  <A HREF="#item_ARG1"><CODE>ARG1</CODE></A> is just <CODE>ARG0+1</CODE>, and so on.</P>
<P></P>
<DT><STRONG><A NAME="item_HEAP">HEAP</A></STRONG><BR>
<DD>
<A HREF="#item_HEAP"><CODE>HEAP</CODE></A> is a session's unique runtime storage space.  It's separate
from everything else so that Session authors don't need to worry about
namespace collisions.
<P>States that store their runtime values in the <A HREF="#item_HEAP"><CODE>HEAP</CODE></A> will always be
saving it in the correct session.  This makes them re-entrant, which
will be a factor when Perl's threading stops being experimental.</P>
<PRE>
  sub _start {
    $_[HEAP]-&gt;{start_time} = time();
  }</PRE>
<PRE>
  sub _stop {
    my $elapsed_runtime = time() - $_[HEAP]-&gt;{start_time};
    print 'Session ', $_[SESSION]-&gt;ID, &quot; elapsed runtime: $elapsed_runtime\n&quot;;
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_KERNEL">KERNEL</A></STRONG><BR>
<DD>
<A HREF="#item_KERNEL"><CODE>KERNEL</CODE></A> is a reference to the Kernel.  It's used to access the
Kernel's methods from within states.
<PRE>
  # Fire a &quot;time_is_up&quot; event in ten seconds.
  $_[KERNEL]-&gt;delay( time_is_up =&gt; 10 );</PRE>
<P>It can also be used with <A HREF="#item_SENDER"><CODE>SENDER</CODE></A> to make sure Kernel events have
actually come from the Kernel.</P>
<P></P>
<DT><STRONG><A NAME="item_OBJECT">OBJECT</A></STRONG><BR>
<DD>
<A HREF="#item_OBJECT"><CODE>OBJECT</CODE></A> is only meaningful in object and package states.
<P>In object states, it contains a reference to the object whose method
is being invoked.  This is useful for invoking plain object methods
once an event has arrived.</P>
<PRE>
  sub ui_update_everything {
    my $object = $_[OBJECT];
    $object-&gt;update_menu();
    $object-&gt;update_main_window();
    $object-&gt;update_status_line();
  }</PRE>
<P>In package states, it contains the name of the package whose method is
being invoked.  Again, it's useful for invoking plain package methods
once an event has arrived.</P>
<PRE>
  sub Package::_stop {
    $_[PACKAGE]-&gt;shutdown();
  }</PRE>
<P><A HREF="#item_OBJECT"><CODE>OBJECT</CODE></A> is undef in inline states.</P>
<P></P>
<DT><STRONG><A NAME="item_SENDER">SENDER</A></STRONG><BR>
<DD>
<A HREF="#item_SENDER"><CODE>SENDER</CODE></A> is a reference to the session that sent an event.  It can be
used as a return address for service requests.  It can also be used to
validate events and ignore them if they've come from unexpected
places.
<P>This example shows both common uses.  It posts a copy of an event back
to its sender unless the sender happens to be itself.  The condition
is important in preventing infinite loops.</P>
<PRE>
  sub echo_event {
    $_[KERNEL]-&gt;post( $_[SENDER], $_[STATE], @_[ARG0..$#_] )
      unless $_[SENDER] == $_[SESSION];
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_SESSION">SESSION</A></STRONG><BR>
<DD>
<A HREF="#item_SESSION"><CODE>SESSION</CODE></A> is a reference to the current session.  This lets states
access their own session's methods, and it's a convenient way to
determine whether <A HREF="#item_SENDER"><CODE>SENDER</CODE></A> is the same session.
<PRE>
  sub enable_trace {
    $_[SESSION]-&gt;option( trace =&gt; 1 );
    print &quot;Session &quot;, $_[SESSION]-&gt;ID, &quot;: dispatch trace is now on.\n&quot;;
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_STATE">STATE</A></STRONG><BR>
<DD>
<A HREF="#item_STATE"><CODE>STATE</CODE></A> contains the event name that invoked a state.  This is useful
in cases where a single state handles several different events.
<PRE>
  sub some_state {
    print( &quot;some_state in session &quot;, $_[SESSION]-ID,
           &quot; was invoked as &quot;, $_[STATE], &quot;\n&quot;
         );
  }</PRE>
<PRE>
  <A HREF=/docs/POE/Session.html>POE::Session</A>-&gt;create(
    inline_states =&gt;
    { one =&gt; \&amp;some_state,
      two =&gt; \&amp;some_state,
      six =&gt; \&amp;some_state,
      ten =&gt; \&amp;some_state,
    }
  );</PRE>
<P>The most common use is in the <A HREF="#item__default"><CODE>_default</CODE></A> state, which can be invoked
by almost anything.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="predefined event names">PREDEFINED EVENT NAMES</A></H1>
<P>POE contains helpers which, in order to help, need to emit predefined
events.  These events all being with a single leading underscore, and
it's recommended that sessions not post leading-underscore events
unless they know what they're doing.</P>
<P>Predefined events generally have serious side effects.  The <A HREF="#item__start"><CODE>_start</CODE></A>
event, for example, performs a lot of internal session initialization.
Posting a redundant <A HREF="#item__start"><CODE>_start</CODE></A> event may try to allocate a session that
already exists, which in turn would do terrible, horrible things to
the Kernel's internal data structures.  Such things would normally be
outlawed outright, but the extra overhead to check for them would slow
everything down all the time.  Please be careful!  The clock cycles
you save may be your own.</P>
<P>These are the predefined events, why they're emitted, and what their
parameters mean.</P>
<DL>
<DT><STRONG><A NAME="item__child">_child</A></STRONG><BR>
<DD>
<A HREF="#item__child"><CODE>_child</CODE></A> is a job-control event.  It notifies a parent session when
its set of child sessions changes.
<P><A HREF="#item_ARG0"><CODE>ARG0</CODE></A> contains one of three strings describing what is happening to
the child session.</P>
<DL>
<DT><STRONG><A NAME="item_%27create%27">'create'</A></STRONG><BR>
<DD>
A child session has just been created, and the current session is its
original parent.
<P></P>
<DT><STRONG><A NAME="item_%27gain%27">'gain'</A></STRONG><BR>
<DD>
This session is gaining a new child from a child session that has
stopped.  A grandchild session is being passed one level up the
inheritance tree.
<P></P>
<DT><STRONG><A NAME="item_%27lose%27">'lose'</A></STRONG><BR>
<DD>
This session is losing a child which has stopped.
<P></P></DL>
<P><A HREF="#item_ARG1"><CODE>ARG1</CODE></A> is a reference to the child session.  It will still be valid,
even if the child is in its death throes, but it won't last long
enough to receive posted events.  If the parent must interact with
this child, it should do so with <CODE>call()</CODE> or some other means.</P>
<P><A HREF="#item_ARG2"><CODE>ARG2</CODE></A> is only valid when a new session has been created.  When
<A HREF="#item_ARG0"><CODE>ARG0</CODE></A> is 'create', this holds the new session's <A HREF="#item__start"><CODE>_start</CODE></A> state's
return value.</P>
<DT><STRONG><A NAME="item__default">_default</A></STRONG><BR>
<DD>
<A HREF="#item__default"><CODE>_default</CODE></A> is the event that's delivered whenever an event isn't
handled.  The unhandled event becomes parameters for <A HREF="#item__default"><CODE>_default</CODE></A>.
<P>It's perfectly okay to post events to a session that can't handle
them.  When this occurs, the session's <A HREF="#item__default"><CODE>_default</CODE></A> handler is invoked
instead.  If the session doesn't have a <A HREF="#item__default"><CODE>_default</CODE></A> handler, then the
event is quietly discarded.</P>
<P>Quietly discarding events is a feature, but it makes catching mistyped
event names kind of hard.  There are a couple ways around this: One is
to define event names as symbolic constants.  Perl will catch typos at
compile time.  The second way around it is to turn on a session's
<CODE>debug</CODE> option (see Session's <CODE>option()</CODE> method).  This makes
unhandled events hard runtime errors.</P>
<P>As was previously mentioned, unhandled events become <A HREF="#item__default"><CODE>_default</CODE></A>'s
parameters.  The original state's name is preserved in <A HREF="#item_ARG0"><CODE>ARG0</CODE></A> while
its custom parameter list is preserved as a reference in <A HREF="#item_ARG1"><CODE>ARG1</CODE></A>.</P>
<PRE>
  sub _default {
    print &quot;Default caught an unhandled $_[ARG0] event.\n&quot;;
    print &quot;The $_[ARG0] event was given these parameters: @{$_[ARG1]}\n&quot;;
  }</PRE>
<P>All the other <A HREF="#item__default"><CODE>_default</CODE></A> parameters are the same as the unhandled
event's, with the exception of <A HREF="#item_STATE"><CODE>STATE</CODE></A>, which becomes <A HREF="#item__default"><CODE>_default</CODE></A>.</P>
<P><STRONG>Beware!</STRONG> A <A HREF="#item__default"><CODE>_default</CODE></A> handler will catch unhandled signal events.
In this case, <A HREF="#item__default"><CODE>_default</CODE></A>'s return value is used to determine whether
the signal has been handled.  If any <A HREF="#item__default"><CODE>_default</CODE></A> handler always
returns true, then it will catch all but the nonmaskable signals, and
only SIGKILL may stop them.</P>
<P><A HREF="/POE/Kernel.html">the <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> manpage</A> discusses signal handlers in ``Signal Watcher Methods''.
It also covers the pitfals of <A HREF="#item__default"><CODE>_default</CODE></A> states in more detail</P>
<P></P>
<DT><STRONG><A NAME="item__parent">_parent</A></STRONG><BR>
<DD>
<A HREF="#item__parent"><CODE>_parent</CODE></A> It notifies child sessions that their parent sessions are
in the process of changing.  It is the complement to <A HREF="#item__child"><CODE>_child</CODE></A>.
<P><A HREF="#item_ARG0"><CODE>ARG0</CODE></A> contains the session's previous parent, and <A HREF="#item_ARG1"><CODE>ARG1</CODE></A> contains
its new parent.</P>
<P></P>
<DT><STRONG><A NAME="item__signal">_signal</A></STRONG><BR>
<DD>
<A HREF="#item__signal"><CODE>_signal</CODE></A> is a session's default signal handler.  Every signal that
isn't mapped to a specific state will be delivered to this one.
<P><A HREF="#item_ARG0"><CODE>ARG0</CODE></A> contains the signal's name as it appears in Perl's %SIG hash.
That is, it's the root name of the signal without the SIG prefix.</P>
<P>Unhandled <A HREF="#item__signal"><CODE>_signal</CODE></A> events will be forwarded to <A HREF="#item__default"><CODE>_default</CODE></A>.  In this
case, the <A HREF="#item__default"><CODE>_default</CODE></A> handler's return value becomes significant.
It's possible to accidentally write unkillable programs this way.</P>
<P>If <A HREF="#item__signal"><CODE>_signal</CODE></A> and <A HREF="#item__default"><CODE>_default</CODE></A> handlers don't exist, then signals will
always be unhandled.</P>
<P><A HREF="/POE/Kernel.html">the <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> manpage</A>'s ``Signal Watcher Methods'' section is recommended
reading before using <A HREF="#item__signal"><CODE>_signal</CODE></A> or <A HREF="#item__default"><CODE>_default</CODE></A>.  It discusses the
different signal levels, the mechanics of signal propagation, and why
it's always important to return an explicit value from a signal
handler, among other things.</P>
<P></P>
<DT><STRONG><A NAME="item__start">_start</A></STRONG><BR>
<DD>
<A HREF="#item__start"><CODE>_start</CODE></A> is a session's initialization event.  It tells a session
that the Kernel has allocated and initialized resources for it, and it
may now start doing things.  A session's constructors invokes the
<A HREF="#item__start"><CODE>_start</CODE></A> handler before it returns, so it's possible for some
sessions' <A HREF="#item__start"><CODE>_start</CODE></A> states to run before $poe_kernel-&gt;<CODE>run()</CODE> is called.
<P>Every session must have a <A HREF="#item__start"><CODE>_start</CODE></A> handler.  Its parameters are
slightly different from normal ones.</P>
<P><A HREF="#item_SENDER"><CODE>SENDER</CODE></A> contains a reference to the new session's parent.  Sessions
created before $poe_kernel-&gt;<CODE>run()</CODE> is called will have <A HREF="#item_KERNEL"><CODE>KERNEL</CODE></A> as
their parents.</P>
<P><CODE>ARG0..$#_</CODE> contain the parameters passed into the Session's
constructor.  See Session's <CODE>new()</CODE> and <CODE>create()</CODE> methods for more
information on passing parameters to new sessions.</P>
<P></P>
<DT><STRONG><A NAME="item__stop">_stop</A></STRONG><BR>
<DD>
<A HREF="#item__stop"><CODE>_stop</CODE></A> is sent to a session when it's about to stop.  This usually
occurs when a session has run out of events to handle and resources to
generate new events.
<P>The <A HREF="#item__stop"><CODE>_stop</CODE></A> handler is used to perform shutdown tasks, such as
releasing custom resources and breaking circular references so that
Perl's garbage collection will properly destroy things.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="miscellaneous concepts">MISCELLANEOUS CONCEPTS</A></H1>
<P>
<H2><A NAME="states' return values">States' Return Values</A></H2>
<P>States are always evaluated in a scalar context.  States that must
return more than one value should therefore return them as a reference
to something bigger.</P>
<P>Signal handlers' return values are significant.  <A HREF="/POE/Kernel.html">the <A HREF=/docs/POE/Kernel.html>POE::Kernel</A> manpage</A>'s
``Signal Watcher Methods'' sections covers this is detail.</P>
<P>States may not return references to objects in the ``POE'' namespace.
The Kernel will stringify these references to prevent them from
lingering and beraking its own garbage collection.</P>
<P>
<H2><A NAME="resource tracking">Resource Tracking</A></H2>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A> tracks resources on behalf of its active sessions.  It
generates events corresponding to these resources' activity, notifying
sessions when it's time to do things.</P>
<P>The conversation goes something like this.</P>
<PRE>
  Session: Be a dear, Kernel, and let me know when someone clicks on
           this widget.  Thanks so much!</PRE>
<PRE>
  [TIME PASSES]  [SFX: MOUSE CLICK]</PRE>
<PRE>
  Kernel: Right, then.  Someone's clicked on your widget.
          Here you go.</PRE>
<P>Furthermore, since the Kernel keeps track of everything sessions do,
it knows when a session has run out of tasks to perform.  When this
happens, the Kernel emits a <A HREF="#item__stop"><CODE>_stop</CODE></A> event at the dead session so it
can clean up and shutdown.</P>
<PRE>
  Kernel: Please switch off the lights and lock up; it's time to go.</PRE>
<P>Likewise, if a session stops on its own and there still are opened
resource watchers, the Kernel knows about them and cleans them up on
the session's behalf.  POE excels at long-running services because it
so meticulously tracks and cleans up its resources.</P>
<P>
<H2><A NAME="synchronous and asynchronous events">Synchronous and Asynchronous Events</A></H2>
<P>While time's passing, however, the Kernel may be telling Session other
things are happening.  Or it may be telling other Sessions about
things they're interested in.  Or everything could be quiet... perhaps
a little too quiet.  Such is the nature of non-blocking, cooperative
timeslicing, which makes up the heart of POE's threading.</P>
<P>Some resources must be serviced right away, or they'll faithfully
continue reporting their readiness.  These reports would appear as a
stream of duplicate events, which would be bad.  Filehandles are like
this: They remain ready as long as they're not serviced.  For this
reason, some events (namely filehandle readiness events) invoke their
handlers immediately.  These are ``synchronous'' events because they're
handled right away.</P>
<P>The other kind of event is called ``asynchronous'' because they're
posted and dispatched through a queue.  There's no telling just when
they'll arrive.</P>
<P>Synchronous event handlers should perform simple tasks limited to
handling the resources that invoked them.  They are very much like
device drivers in this regard.</P>
<P>Synchronous events that need to do more than just service a resource
should pass the resource's information to an asynchronous handler.
Otherwise synchronous operations will occur out of order in relation
to asynchronous events.  It's very easy to have race conditions or
break causality this way, so try to avoid it unless you're okay with
the consequences.</P>
<P>
<H2><A NAME="postbacks">Postbacks</A></H2>
<P>Many external libraries expect plain coderef callbacks, but sometimes
programs could use asynchronous events instead.  <A HREF=/docs/POE/Session.html>POE::Session</A>'s
<CODE>postback()</CODE> method was created to fill this need.</P>
<P><CODE>postback()</CODE> creates coderefs suitable to be used in traditional
callbacks.  When invoked as callbacks, these coderefs post their
parameters as POE events.  This lets POE interact with nearly every
callback currently in existing, and most future ones.</P>
<P>
<H2><A NAME="job control and family values">Job Control and Family Values</A></H2>
<P>Sessions are resources, too.  The Kernel watches sessions come and go,
maintains parent/child relationships, and notifies sessions when these
relationships change.  These events, <A HREF="#item__parent"><CODE>_parent</CODE></A> and <A HREF="#item__child"><CODE>_child</CODE></A>, are
useful for job control and managing pools of worker sessions.</P>
<P>Parent/child relationships are maintained automatically.  ``Child''
sessions simply are ones which have been created from an existing
session.  The existing session which created a child becomes its
``parent''.</P>
<P>A session with children will not spontaneously stop.  In other words,
the presence of child sessions will keep a parent alive.</P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P><A HREF=/docs/POE/Kernel.html>POE::Kernel</A>.</P>
<P>The <A HREF=/docs/POE.html#see also>SEE ALSO section in <EM>POE</EM></A> contains a table of contents covering
the entire POE distribution.</P>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P>There is a chance that session IDs may collide after Perl's integer
value wraps.  This can occur after as few as 4.29 billion sessions.</P>
<P>
<HR>
<H1><A NAME="authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></H1>
<P>Please <A HREF=/docs/POE.html>see <EM>POE</EM></A> for more information about authors and contributors.</P>

</BODY>

</HTML>
