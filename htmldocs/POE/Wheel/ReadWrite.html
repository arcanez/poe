<HTML>
<HEAD>
<TITLE><A HREF=/docs/POE/Wheel/ReadWrite.html>POE::Wheel::ReadWrite</A> - buffered non-blocking I/O</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD WIDTH="30">
<img HSPACE="0" VSPACE="0" border="0" src="/images/L-circle.jpg" align="left" alt="" width="30" height="60">
</TD><TD ALIGN="Center" WIDTH=100% BGCOLOR="#000000">
<STRONG><font color="#FFFFFF" size="5"><A HREF=/docs/POE/Wheel/ReadWrite.html>POE::Wheel::ReadWrite</A> - buffered non-blocking I/O</font></STRONG></TD><TD>
<img HSPACE="0" VSPACE="0" border="0" src="/images/R-circle.jpg" align="right" alt="" width="30" height="60">
</TD></TR></TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#public methods">PUBLIC METHODS</A></LI>
	<LI><A HREF="#events and parameters">EVENTS AND PARAMETERS</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P><A HREF=/docs/POE/Wheel/ReadWrite.html>POE::Wheel::ReadWrite</A> - buffered non-blocking I/O</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
  $wheel = <A HREF=/docs/POE/Wheel/ReadWrite.html>POE::Wheel::ReadWrite</A>-&gt;new(</PRE>
<PRE>
    # To read and write from the same handle, such as a socket, use
    # the Handle parameter:
    Handle       =&gt; $file_or_socket_handle,  # Handle to read/write</PRE>
<PRE>
    # To read and write from different handles, such as a dual pipe to
    # a child process, or a console, use InputHandle and OutputHandle:
    InputHandle  =&gt; $readable_filehandle,    # Handle to read
    OutputHandle =&gt; $writable_filehandle,    # Handle to write</PRE>
<PRE>
    Driver       =&gt; POE::Driver::Something-&gt;new(), # How to read/write it</PRE>
<PRE>
    # To read and write using the same line discipline, such as
    # Filter::Line, use the Filter parameter:
    Filter       =&gt; POE::Filter::Something-&gt;new(), # How to parse in and out</PRE>
<PRE>
    # To read and write using different line disciplines, such as
    # stream out and line in:
    InputFilter  =&gt; POE::Filter::Something-&gt;new(),     # Read data one way
    OUtputFilter =&gt; POE::Filter::SomethingElse-&gt;new(), # Write data another</PRE>
<PRE>
    InputState   =&gt; $input_state_name,  # Input received state
    FlushedState =&gt; $flush_state_name,  # Output flushed state
    ErrorState   =&gt; $error_state_name,  # Error occurred state</PRE>
<PRE>
    # To enable callbacks for high and low water events (using any one
    # of these options requires the rest):
    HighMark  =&gt; $high_mark_octets, # Outgoing high-water mark
    HighState =&gt; $high_mark_state,  # State to call when high-water reached
    LowMark   =&gt; $low_mark_octets,  # Outgoing low-water mark
    LowState  =&gt; $low_mark_state,   # State to call when low-water reached
  );</PRE>
<PRE>
  $wheel-&gt;put( $something );
  $wheel-&gt;event( ... );</PRE>
<PRE>
  # To set both the input and output filters at once:
  $wheel-&gt;set_filter( POE::Filter::Something-&gt;new() );</PRE>
<PRE>
  # To set an input filter or an output filter:
  $wheel-&gt;set_input_filter( POE::Filter::Something-&gt;new() );
  $wheel-&gt;set_output_filter( POE::Filter::Something-&gt;new() );</PRE>
<PRE>
  # To alter the high or low water marks:
  $wheel-&gt;set_high_mark( $new_high_mark_octets );
  $wheel-&gt;set_low_mark( $new_low_mark_octets );</PRE>
<PRE>
  # To fetch driver statistics:
  $pending_octets   = $wheel-&gt;get_driver_out_octets();
  $pending_messages = $wheel-&gt;get_driver_out_messages();</PRE>
<PRE>
  # To retrieve the wheel's ID:
  print $wheel-&gt;ID;</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>ReadWrite performs buffered, select-based I/O on filehandles.  It
generates events for common file conditions, such as when data has
been read or flushed.</P>
<P>
<HR>
<H1><A NAME="public methods">PUBLIC METHODS</A></H1>
<DL>
<DT><STRONG><A NAME="item_put_LISTREF_OF_RECORDS">put LISTREF_OF_RECORDS</A></STRONG><BR>
<DD>
<CODE>put()</CODE> queues records for transmission.  They may not be transmitted
immediately.  ReadWrite uses its Filter to translate the records into
a form suitable for writing.  It uses its Driver to queue and send
them.
<P><CODE>put()</CODE> accepts a reference to a list of records.  It returns a boolean
value indicating whether the wheel's high-water mark has been reached.
It always returns false if a wheel doesn't have a high-water mark set.</P>
<P>This will quickly fill a wheel's output queue if it has a high-water
mark set.  Otherwise it will loop infinitely, eventually exhausting
memory.</P>
<PRE>
  1 while $wheel-&gt;put( &amp;get_next_thing_to_send );</PRE>
<P></P>
<DT><STRONG><A NAME="item_event_EVENT_TYPE_%3D%3E_EVENT_NAME%2C_%2E%2E%2E">event EVENT_TYPE =&gt; EVENT_NAME, ...</A></STRONG><BR>
<DD>
<CODE>event()</CODE> is covered in the <A HREF=/docs/POE/Wheel.html>POE::Wheel</A> manpage.
<P></P>
<DT><STRONG><A NAME="item_set_filter_POE_FILTER">set_filter POE_FILTER</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_set_input_filter_POE_FILTER">set_input_filter POE_FILTER</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_set_output_filter_POE_FILTER">set_output_filter POE_FILTER</A></STRONG><BR>
<DD>
<CODE>set_input_filter()</CODE> changes the filter a wheel uses for reading.
<CODE>set_output_filter()</CODE> changes a wheel's output filter.  <CODE>set_filter()</CODE>
changes them both at once.
<P>These methods let programs change a wheel's underlying protocol while
it runs.  It retrieves the existing filter's unprocessed input using
its <CODE>get_pending()</CODE> method and passes that to the new filter.</P>
<P>Switching filters can be tricky.  Please see the discussion of
<CODE>get_pending()</CODE> in <A HREF="/POE/Filter.html">the <A HREF=/docs/POE/Filter.html>POE::Filter</A> manpage</A>.</P>
<P>The HTTPD filter does not support get_pending(), and it will complain
if a program tries to switch away from one.</P>
<P></P>
<DT><STRONG><A NAME="item_get_input_filter">get_input_filter</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_get_output_filter">get_output_filter</A></STRONG><BR>
<DD>
Return the wheel's input or output filter.  In many cases, they both
may be the same.  This is used to access custom methods on the filter
itself; for example, Filter::Stackable has methods to push and pop
filters on its stack.
<PRE>
  $wheel-&gt;get_input_filter()-&gt;pop();</PRE>
<P></P>
<DT><STRONG><A NAME="item_set_high_mark_HIGH_MARK_OCTETS">set_high_mark HIGH_MARK_OCTETS</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_set_low_mark_LOW_MARK_OCTETS">set_low_mark LOW_MARK_OCTETS</A></STRONG><BR>
<DD>
These methods set a wheel's high- and low-water marks.  New values
will not take effect until the next <CODE>put()</CODE> call or internal buffer
flush.  The <CODE>event()</CODE> method can change the events emitted by high- and
low-water marks.
<P></P>
<DT><STRONG><A NAME="item_ID">ID</A></STRONG><BR>
<DD>
The ID method returns a FollowTail wheel's unique ID.  This ID will be
included in every event the wheel generates, and it can be used to
match events with the wheels which generated them.
<P></P></DL>
<P>
<HR>
<H1><A NAME="events and parameters">EVENTS AND PARAMETERS</A></H1>
<DL>
<DT><STRONG><A NAME="item_InputState">InputState</A></STRONG><BR>
<DD>
InputState contains the event that the wheel emits for every complete
record read.  Every InputState event is accompanied by two parameters.
<CODE>ARG0</CODE> contains the record which was read.  <CODE>ARG1</CODE> contains the
wheel's unique ID.
<P>A sample InputState event handler:</P>
<PRE>
  sub input_state {
    my ($heap, $input, $wheel_id) = @_[HEAP, ARG0, ARG1];
    print &quot;Echoing input from wheel $wheel_id: $input\n&quot;;
    $heap-&gt;{wheel}-&gt;put($input);     # Echo it back.
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_FlushedState">FlushedState</A></STRONG><BR>
<DD>
FlushedState contains the event that ReadWrite emits whenever its
output queue becomes empty.  This signals that all pending data has
been written, and it's often used to wait for ``goodbye'' messages to be
sent before a session shuts down.
<P>FlushedState comes with a single parameter, <CODE>ARG0</CODE>, that indicates
which wheel flushed its buffer.</P>
<P>A sample FlushedState event handler:</P>
<PRE>
  sub flushed_state {
    # Stop a wheel after all outgoing data is flushed.
    # This frees the wheel's resources, including the
    # filehandle, and closes the connection.
    delete $_[HEAP]-&gt;{wheel}-&gt;{$_[ARG0]};
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_ErrorState">ErrorState</A></STRONG><BR>
<DD>
ErrorState contains the event that ReadWrite emits whenever an error
occurs.  Every ErrorState event comes with four parameters:
<P><CODE>ARG0</CODE> contains the name of the operation that failed.  This usually
is 'read'.  Note: This is not necessarily a function name.  The wheel
doesn't know which function its Driver is using.</P>
<P><CODE>ARG1</CODE> and <CODE>ARG2</CODE> hold numeric and string values for <CODE>$!</CODE>,
respectively.</P>
<P><CODE>ARG3</CODE> contains the wheel's unique ID.</P>
<P>A sample ErrorState event handler:</P>
<PRE>
  sub error_state {
    my ($operation, $errnum, $errstr, $wheel_id) = @_[ARG0..ARG3];
    warn &quot;Wheel $wheel_id generated $operation error $errnum: $errstr\n&quot;;
    delete $heap-&gt;{wheels}-&gt;{$wheel_id}; # shut down that wheel
  }</PRE>
<P></P>
<DT><STRONG><A NAME="item_HighState">HighState</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_LowState">LowState</A></STRONG><BR>
<DD>
ReadWrite emits a HighState event when a wheel's pending output queue
has grown to be at least HighMark octets.  A LowState event is emitted
when a wheel's pending octet count drops below the value of LowMark.
<P>HighState and LowState flip-flop.  Once a HighState event has been
fired, it won't be fired again until LowState's event is.  Likewise,
LowState will not be fired again until HighState is.  ReadWrite always
starts in a low-water state.</P>
<P>Streaming sessions are encouraged to used these states for flow
control.  Sessions can reduce their transmission rates or stop
transmitting altogether upon receipt of a HighState event.  They can
resume full-speed transmission once LowState arrives.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P><A HREF=/docs/POE/Wheel.html>POE::Wheel</A>.</P>
<P>The <A HREF=/docs/POE.html#see also>SEE ALSO section in <EM>POE</EM></A> contains a table of contents covering
the entire POE distribution.</P>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P>Oh, probably some.</P>
<P>
<HR>
<H1><A NAME="authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></H1>
<P>Please <A HREF=/docs/POE.html>see <EM>POE</EM></A> for more information about authors and contributors.</P>

</BODY>

</HTML>
