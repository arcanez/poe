<HTML>
<HEAD>
<TITLE><A HREF=/docs/POE/Wheel/ReadLine.html>POE::Wheel::ReadLine</A> - prompted terminal input with basic editing keys</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD WIDTH="30">
<img HSPACE="0" VSPACE="0" border="0" src="/images/L-circle.jpg" align="left" alt="" width="30" height="60">
</TD><TD ALIGN="Center" WIDTH=100% BGCOLOR="#000000">
<STRONG><font color="#FFFFFF" size="5"><A HREF=/docs/POE/Wheel/ReadLine.html>POE::Wheel::ReadLine</A> - prompted terminal input with basic editing keys</font></STRONG></TD><TD>
<img HSPACE="0" VSPACE="0" border="0" src="/images/R-circle.jpg" align="right" alt="" width="30" height="60">
</TD></TR></TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#editing keys">EDITING KEYS</A></LI>
	<LI><A HREF="#public methods">PUBLIC METHODS</A></LI>
	<LI><A HREF="#events and parameters">EVENTS AND PARAMETERS</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P><A HREF=/docs/POE/Wheel/ReadLine.html>POE::Wheel::ReadLine</A> - prompted terminal input with basic editing keys</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
  # Create the wheel.
  $heap-&gt;{wheel} = <A HREF=/docs/POE/Wheel/ReadLine.html>POE::Wheel::ReadLine</A>-&gt;new( InputEvent =&gt; got_input );</PRE>
<PRE>
  # Trigger the wheel to read a line of input.
  $wheel-&gt;get( 'Prompt: ' );</PRE>
<PRE>
  # Add a line to the wheel's input history.
  $wheel-&gt;addhistory( $input );</PRE>
<PRE>
  # Input handler.  If $input is defined, then it contains a line of
  # input.  Otherwise $exception contains a word describing some kind
  # of user exception.  Currently these are 'interrupt' and 'cancel'.
  sub got_input_handler {
    my ($heap, $input, $exception) = @_[HEAP, ARG0, ARG1];
    if (defined $input) {
      $heap-&gt;{wheel}-&gt;addhistory($input);
      print &quot;\tGot: $input\n&quot;;
      $heap-&gt;{wheel}-&gt;get('Prompt: '); # get another line
    }
    else {
      print &quot;\tException: $exception\n&quot;;
    }
  }</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>ReadLine performs non-blocking, event-driven console input, using
Term::Cap to interact with the terminal display and Term::ReadKey to
interact with its keyboard.</P>
<P>ReadLine handles a number of common input editing keys; it also
provides an input history list.  It's not, however, a fully featured
Term::ReadLine replacement, although it probably will approach one
over time.</P>
<P>
<HR>
<H1><A NAME="editing keys">EDITING KEYS</A></H1>
<P>These are the editing keystrokes that ReadLine uses to facilitate text
editing.  Some of them, such as Home, End, Insert, and Delete, may not
work on every terminal.</P>
<P>Keystrokes are in the form X-y or X-X-z.  X designates a modifier,
which can be C for ``control'' or M for ``meta''.  The only meta key
currently supported is the Escape key, chr(27).</P>
<DL>
<DT><STRONG><A NAME="item_a">C-a (Control-A)</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_Home">Home</A></STRONG><BR>
<DD>
Moves the cursor to the beginning of the line.
<P></P>
<DT><STRONG><A NAME="item_C%2Db">C-b</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_Left_arrow">Left arrow</A></STRONG><BR>
<DD>
Moves the cursor one character back towards the beginning of the line.
<P></P>
<DT><STRONG><A NAME="item_C%2Dc">C-c</A></STRONG><BR>
<DD>
Interrupt the program.  This stops editing the current line and emits
an InputEvent event.  The event's <CODE>ARG0</CODE> parameter is undefined, and
its <CODE>ARG1</CODE> parameter contains the word ``interrupt''.
<P></P>
<DT><STRONG><A NAME="item_C%2Dd">C-d</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_Delete">Delete</A></STRONG><BR>
<DD>
Delete the character under the cursor.
<P></P>
<DT><STRONG><A NAME="item_C%2De">C-e</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_End">End</A></STRONG><BR>
<DD>
Move the cursor to the end of the input line.
<P></P>
<DT><STRONG><A NAME="item_C%2Df">C-f</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_Right_arrow">Right arrow</A></STRONG><BR>
<DD>
Move the cursor one character forward.  This moves it closer to the
end of the line.
<P></P>
<DT><STRONG><A NAME="item_C%2Dg">C-g</A></STRONG><BR>
<DD>
Cancle text entry.  This stops editing the current line and emits an
InputEvent event.  The event's <CODE>ARG0</CODE> parameter is undefined, and its
<CODE>ARG1</CODE> parameter contains the word ``cancel''.
<P></P>
<DT><STRONG><A NAME="item_C%2Dh">C-h</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_Backspace">Backspace</A></STRONG><BR>
<DD>
Delete the character before the cursor.
<P></P>
<DT><STRONG><A NAME="item_C%2Dj">C-j</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_Enter_%2F_Return">Enter / Return</A></STRONG><BR>
<DD>
C-j is the newline keystroke on Unix-y systems.  It ends text entry,
firing an InputEvent with <CODE>ARG0</CODE> containing the entered text (without
the terminating newline).  <CODE>ARG1</CODE> is undefined because there is no
exception.
<P></P>
<DT><STRONG><A NAME="item_C%2Dk">C-k</A></STRONG><BR>
<DD>
Kill to end of line.  Deletes all text from the cursor position to the
end of the line.
<P></P>
<DT><STRONG><A NAME="item_C%2Dl">C-l</A></STRONG><BR>
<DD>
Clear the screen and repaint the prompt and current input line.
<P></P>
<DT><STRONG><A NAME="item_C%2Dm">C-m</A></STRONG><BR>
<DD>
<DT><STRONG>Enter / Return</STRONG><BR>
<DD>
C-m is the newline keystroke on Unix-y systems.  It ends text entry,
firing an InputEvent with <CODE>ARG0</CODE> containing the entered text (without
the terminating newline).  <CODE>ARG1</CODE> is undefined because there is no
exception.
<P></P>
<DT><STRONG><A NAME="item_C%2Dn">C-n</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_Down_arrow">Down arrow</A></STRONG><BR>
<DD>
Scroll forward through the line history list.  This replaces the
current input line with the one entered after it.
<P></P>
<DT><STRONG><A NAME="item_C%2Dp">C-p</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_Up_arrow">Up arrow</A></STRONG><BR>
<DD>
Scroll back through the line history list.  This replaces the current
input line with the one entered before it.
<P></P>
<DT><STRONG><A NAME="item_C%2Dt">C-t</A></STRONG><BR>
<DD>
Transpose the character before the cursor with the one under it.  Tihs
si gerat fro fxiing cmoon tyopes.
<P></P>
<DT><STRONG><A NAME="item_C%2Du">C-u</A></STRONG><BR>
<DD>
Discard the entire line.  Throws away everything and starts anew.
<P></P>
<DT><STRONG><A NAME="item_C%2Dw">C-w</A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_h">M-C-h (Escape Control-h)</A></STRONG><BR>
<DD>
Word rubout.  Discards from just before the cursor to the beginning of
the word immediately before it.
<P></P>
<DT><STRONG><A NAME="item_M%2D%3C_%28Escape%2D%3C%29">M-&lt; (Escape-&lt;)</A></STRONG><BR>
<DD>
First history line.  Replaces the current input line with the first
one in the history list.
<P></P>
<DT><STRONG><A NAME="item_M%2D%3E">M-&gt;</A></STRONG><BR>
<DD>
Last history line.  Replaces the current input line with the last one
in the history list.  Pressing C-n or the down arrow key after this
will recall whatever was being entered before the user began looking
through the history list.
<P></P>
<DT><STRONG><A NAME="item_M%2Db">M-b</A></STRONG><BR>
<DD>
Move the cursor backwards one word.  The cursor's final resting place
is at the start of the word on or before the cursor's original
location.
<P></P>
<DT><STRONG><A NAME="item_M%2Dc">M-c</A></STRONG><BR>
<DD>
Capitalize the first letter on or after the cursor, and lowercase
subsequent characters in the word.  Some examples follow.  The caret
marks the character under the cursor before M-c is pressed.
<PRE>
  capITALize  tHiS   ... becomes ...   Capitalize  tHiS
  ^                                              ^</PRE>
<PRE>
  capITALize  tHiS   ... becomes ...   capITALiZe  tHiS
          ^                                      ^</PRE>
<PRE>
  capITALize  tHiS   ... becomes ...   capITALize  This
            ^                                          ^</PRE>
<P></P>
<DT><STRONG><A NAME="item_M%2Dd">M-d</A></STRONG><BR>
<DD>
Forward word delete.  Deletes from the cursor position to the end of
the first word on or after the cursor.  The text that is deleted is
the same as the text that M-c, M-l, and M-u change.  It also coincides
with the text that M-f skip.
<P></P>
<DT><STRONG><A NAME="item_M%2Df">M-f</A></STRONG><BR>
<DD>
Move the cursor forward one word.  The cursor actually moves to the
end of the first word under or after the cursor.  This motion is the
same for M-c, M-l, and M-u.
<P></P>
<DT><STRONG><A NAME="item_M%2Dl">M-l</A></STRONG><BR>
<DD>
Uppercases the entire word beginning on or after the cursor position.
Here are some examples; the caret points to the character under the
cursor before and after M-u are pressed.
<PRE>
  LOWERCASE  THIS   ... becomes ...   lowercase  THIS
  ^                                            ^</PRE>
<PRE>
  LOWERCASE  THIS   ... becomes ...   LOWERcase  THIS
       ^                                       ^</PRE>
<PRE>
  LOWERCASE  THIS   ... becomes ...   LOWERCASE  this
           ^                                         ^</PRE>
<P></P>
<DT><STRONG><A NAME="item_M%2Dt">M-t</A></STRONG><BR>
<DD>
Transpose words.
<P>If the cursor is within the last word in the input line, then that
word is transposed with the one before it.</P>
<PRE>
  one  two  three   ... becomes ...   one  three  two
               ^                                     ^</PRE>
<P>If the cursor is within any other word in the input line, then that
word is transposed with the next one.</P>
<PRE>
  one  two  three   ... becomes ...   two  one  three
   ^                                          ^</PRE>
<P>If the cursor is in the whitespace between words, then the words on
either side of the whitespace are transposed.</P>
<PRE>
  one  two  three   ... becomes ...   two  one  three
      ^                                       ^</PRE>
<P></P>
<DT><STRONG><A NAME="item_M%2Du">M-u</A></STRONG><BR>
<DD>
Uppercases the entire word beginning on or after the cursor position.
Here are some examples; the caret points to the character under the
cursor before and after M-u are pressed.
<PRE>
  uppercase  this   ... becomes ...   UPPERCASE  this
  ^                                            ^</PRE>
<PRE>
  uppercase  this   ... becomes ...   upperCASE  this
       ^                                       ^</PRE>
<PRE>
  uppercase  this   ... becomes ...   uppercase  THIS
           ^                                         ^</PRE>
<P></P></DL>
<P>
<HR>
<H1><A NAME="public methods">PUBLIC METHODS</A></H1>
<DL>
<DT><STRONG><A NAME="item_get">get PROMPT</A></STRONG><BR>
<DD>
Provide a prompt and enable input.  The wheel will display the prompt
and begin paying attention to the console keyboard after this method
is called.  Once a line or an exception is returned, the wheel will
resume its quiescent state wherein it ignores keystrokes.
<P>The quiet period between input events gives a program the opportunity
to change the prompt or process lines before the next one arrives.</P>
<P></P>
<DT><STRONG><A NAME="item_addhistory_LIST_OF_LINES">addhistory LIST_OF_LINES</A></STRONG><BR>
<DD>
</DL>
<P>
<HR>
<H1><A NAME="events and parameters">EVENTS AND PARAMETERS</A></H1>
<DL>
<DT><STRONG><A NAME="item_InputEvent">InputEvent</A></STRONG><BR>
<DD>
InputEvent contains the name of the event that will be fired upon
successful (or unsuccessful) terminal input.  Every InputEvent handler
receives two additional parameters, only one of which is ever defined
at a time.  <CODE>ARG0</CODE> contains the input line, if one was present.  If
<CODE>ARG0</CODE> is not defined, then <CODE>ARG1</CODE> contains a word describing a
user-generated exception:
<P>The 'interrupt' exception means a user pressed C-c (^C) to interrupt
the program.  It's up to the input event's handler to decide what to
do next.</P>
<P>The 'cancel' exception means a user pressed C-g (^G) to cancel a line
of input.</P>
<P></P>
<DT><STRONG><A NAME="item_PutMode">PutMode</A></STRONG><BR>
<DD>
PutMode specifies how the wheel will display text when its <CODE>put()</CODE>
method is called.
<P><CODE>put()</CODE> displays text immediately when the user isn't being prompted
for input.  It will also pre-empt the user to display text right away
when PutMode is ``immediate''.</P>
<P>When PutMode is ``after'', all <CODE>put()</CODE> text is held until after the
user enters or cancels (See C-g) her input.</P>
<P>PutMode can also be ``idle''.  In this mode, text is displayed right
away if the keyboard has been idle for a certian period (see the
IdleTime parameter).  Otherwise it's held as in ``after'' mode until
input is completed or canceled, or until the keyboard becomes idle for
at least IdleTime seconds.  This is ReadLine's default mode.</P>
<P></P>
<DT><STRONG><A NAME="item_IdleTime">IdleTime</A></STRONG><BR>
<DD>
IdleTime specifies how long the keyboard must be idle before <CODE>put()</CODE>
becomes immediate or buffered text is flushed to the display.  It is
only meaningful when InputMode is ``idle''.  IdleTime defaults to two
seconds.
<P></P></DL>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P><A HREF=/docs/POE/Wheel.html>POE::Wheel</A>.</P>
<P>The <A HREF=/docs/POE.html#see also>SEE ALSO section in <EM>POE</EM></A> contains a table of contents covering
the entire POE distribution.</P>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<DL>
<DT><STRONG><A NAME="item_Non%2Doptimal_code">Non-optimal code</A></STRONG><BR>
<DD>
Dissociating the input and display cursors introduced a lot of code.
Much of this code was thrown in hastily, and things can probably be
done with less work.  To do: Apply some thought to what's already been
done.
<P>The screen should update as quickly as possible, especially on slow
systems.  Do little or no calculation during displaying; either put it
all before or after the display.  Do it consistently for each handled
keystroke, so that certain pairs of editing commands don't have extra
perceived latency.</P>
<P></P>
<DT><STRONG><A NAME="item_Unimplemented_features">Unimplemented features</A></STRONG><BR>
<DD>
Input editing is not kept on one line.  If it wraps, and a terminal
cannot wrap back through a line division, the cursor will become lost.
This bites, and it's the next against the wall in my bug hunting.
<P>Unicode, or at least European code pages.  I feel real bad about
throwing away native representation of all the 8th-bit-set characters.
I also have no idea how to do this, and I don't have a system to test
this.  Patches are recommended.</P>
<P>SIGWINCH tends to kill Perl quickly, and POE ignores it.  Resizing a
terminal window has no effect.  Making this useful will require signal
polling, perhaps in the wheel itself (either as a timer loop, a
keystroke, or per every N keystrokes) or in <A HREF=/docs/POE/Kernel.html>POE::Kernel</A>.  I'm not sure
which yet.</P>
<P>Tab completion:</P>
<PRE>
  C-i     cycle through completions
  C-x *   insert possible completions
  C-x ?   list possible completions
  M-?     list possible completions</PRE>
<P>Input options:</P>
<PRE>
  C-q     quoted insert (unprocessed keystroke)
  M-Tab   insert literal tab
  C-_     undo</PRE>
<P>History searching:</P>
<PRE>
  C-s     search history
  C-r     reverse search history
  C-v     forward search history</PRE>
<P></P></DL>
<P>
<HR>
<H1><A NAME="authors & copyrights">AUTHORS &amp; COPYRIGHTS</A></H1>
<P>Please <A HREF=/docs/POE.html>see <EM>POE</EM></A> for more information about authors and contributors.</P>

</BODY>

</HTML>
