* NAME #® -*- outline -*- ¯

POE-TODO - To-Do List for POE

* DESCRIPTION

Random requests, suggestions and ideas.

People who want to implement something for POE should check the latest
version of this list (to see if anyone has claimed it already), and
let Rocco know (so they can be added to the list).

Also see the POE mailing list, which tends to be pretty quiet.

* TUTORIALS, PAPERS AND OTHER DOCUMENTATION

** Tutorials

POE can be difficult for people to pick up, especially if they're not
familiar with Perl references and objects.  A "gradual" introduction
to state machines and POE is half written.  It discusses things
through Kernel and Session, but it doesn't go into Wheels or the
Object Layer yet.

Freeside suggests:

  "here's an event-driven application domain."
  "here's how people usually do it with select(,,,)."
  "here's how you might want to do it in POE."
  "here are some other cool things POE makes easy."

** Papers

*** Coroutines

It is possible to model coroutines in POE.  Coroutines are a hot
topic, and this would make a nice paper topic.

*** Call With Current Continuation (callcc)

Likewise, it was once lamented that Perl has no callcc (call with
current continuation) function.  POE can simulate callcc, which in
turn can simulate coroutines, threads, and all sorts of things.

** Other Documentation

Crimson suggested that I write a book about POE, using the PCB Q&A
format.  Maybe when POE's design settles down?

Golly, I *hope*, POE's design settles down.

* SUPPORT OTHER SYSTEMS

POE uses a lot of POSIX to be portable, but some systems don't seem to
be POSIX enough.

** MacOS support

I contacted someone about this on Pudge's recommendation, but they
never returned my e-mail.  As far as I can tell, MacOS support is
stillborn.  If anyone would like to pick this up, let me know.  It's
all POSIX-y inside, so how hard could it be?

** Win32 support

Sean Puckett started work on a Win32 port then switched to Linux.  Now
he's gone missing.  If anyone would like to pick this up, let me know.

* PROGRAMS USING POE

** tail + grep

Someone (I've forgotten who) wants a program that combines the
features of /usr/bin/grep and /usr/bin/tail.

** POE::Simple

Philip Gwyn would like to see a POE::Simple::(Client|Server|Proxy)
that combines a lot of default behavior into an extremely-high-level
module for writing quick network programs.

He says, "Contrast LWP::Simple with the other modules."  Fair enough.

* DEVELOPMENT METHODOLOGY CHANGES

** CVS

Development is now running out of a local CVS repository.  It's on my
dialed-up machine, so the address changes all the time.

The next step is to open the CVS server for anonymous updates,
possibly moving it somewhere that doesn't move around all the time.

After anonymous updates are working for a while, it should be okay to
start giving authorship rights to some of the more dedicated POE
kernel hackers.

** Namespaces

*** Components

Artur suggested reservinig a slice of the POE namespace for
contributed and third-party modules.  This slice eventually became the
POE::Component namespace.

POE::Component things should be stand-alone daemon-able sessions that
talk via call/post to some public states.  These would be "black box"
sessions, like Visual Age or Digital Smalltalk "parts", or Java
"beans".  See POE::Component::IRC, for example.

Sean Puckett suggests that POE::Components have some facility for
other sessions to query and grok their public interfaces.  This would
be similar to CORBA, COM or SOM objects.  Sounds neat; I hope it's
doable.  See the CORBA notes.

*** Stand-Alone Programs

Stand-alone programs (or "applications" or "apps" as they're called in
some circles) don't need a special namespace.  If someone wants to
write a whole program as an object, and have meta-programs manipulate
things through an object interface, and they really need the object's
package to starte with POE, then they can use POE::App.

For example, uh, POE::App::Poepopper would be a POP3 daemon
implemented as an object, with some public methods to tweak its
configuration.

This is not a recommendation.

*** Core Contributions

Filters, Drivers, Wheels and whatever.  Where do they go?  As long as
there are corresponding test programs, I can absorb them into POE's
core distribution.  Big ones may need to stay separate.

With CVS fully implemented, people could maintain their bits in the
core.  That could be real nice, except that huge, monolithic
distributions tend to suck.

* DESIGN CONSIDERATIONS

** Minor Interface Nits

Some functions only check for undef.  These should really check for
undef or @_==1, since the second parameter may be missing.

If a wheel has no ErrorState, the default behavior should be to issue
a warning with $!.

Consolidate FailureState and ErrorState, so people don't have to
remember when to use one or the other.

Add 'DEFAULT' and 'IGNORE' as special event handlers for
POE::Kernel::sig().

Make the Session::option(default) value mean things.  ($value & 1)
would determine whether POE displaed internal events; ($value & 2)
would determine if dropped user events were displayed.

** Major Nits

It's becoming unfun to run samples/*.perl before each release.  POE
badly needs some sort of automated test suite.

SocketFactory doesn't support connectionless sockets.

Wheels need to be able to stack things.

** Reorganize Wheels

I think the Wheels abstraction should be reorganized into a new
taxonomy:

*** Stream

Streams are read and written in whatever chunks they receive.
POE::Filter::Lecks would probably exist here.

*** Block

Blocks would be subdivided:

**** Separated

Blocks that are identified by separators.  POE::Filter::Line goes
here.

**** Enumerated

Blocks that are identified by length.  This includes fixed-width
records and variable-width records that begin with a length marker.
POE::Filter::Reference belongs here.

*** Form

Forms are read/written as anonymous hashrefs:

  { Headers => { $header_1 => $value_1,
                 $header_2 => $value_2,
                 ...
               },
    Fields  => { $field_1 => $value_1,
                 $field_2 => $value_2,
                 ...
               },
  }

It would be up to the specific Form filters to figure out a way to
render forms.  Perhaps one of the Headers could contain meta-layout
information.

POE::Filter::HTTPD goes here.  As would a new filter for screen
widgets.  The nice thing about this scheme is that sessions wouldn't
need to know what sort of form interface they're using.  It could be
Tk widgets, Face widgets or CGI.

** Self-Knowledgeable Components

Fairytale stuff.  It's here so I don't forget it.

What if the Filter::Reference is chained off Filter::Line instead of
Filter::Block?

The "chaining" could be made internal to Filter::Reference, so it
automagically brings in Filter::Block.  That would prevent people from
chaining incompatible filters together, but it would limit their
flexibility.

Or components (wheels, filters and drivers) could be made aware of the
other components they're working with.  That would give them an
opportunity to verify that they're working with compatible components.
It might also allow components to alter their default behaviors.  For
example, Filter::Reference might make sure to escape/unescape newline
characters if it's working with a Filter::Line.  It might even go so
far as to query the Filter::Line about the newline characters it needs
to escape.

** Tie %SIG

Tom Christiansen says it's bad news to tie %SIG, but he didn't explain
it.  I'll have to try it at least once to see why.

Assume tied %SIG is bad.  Make it %SIGNAL instead.

Storing to %SIGNAL would seem to work exactly like Perl's %SIG does
now.  Internally, it would either register the state name or create a
state for the coderef being stored.  For example:

  $SIGNAL{HUP} = \&sighup_state;
  $SIGNAL{HUP} = 'sighup_state';

And 'DEFAULT' and 'IGNORE' would do the right things, too.

** Fix Signals

Write an XS that polls signals in the relative safety of C.  Use POSIX
signal functions to block signals until a critical section of C code.
Unblock them there, and the signals should hit in the C code.  That'll
prevent them from corrupting perl, I hope.

SIGPIPE can be faked.  Block it entirely, and simulate it when a file
operation catches EPIPE.  No OS signals involved, and wheels can post
signals to the appropriate sessions-- even in Concurrent POE with
multiple kernels.

SIGCH?LD can be faked.  Use SysV semaphores, SysV shared memory, pipes
or sockets.  Lock files, maybe.  Or perhaps poll for children instead
of waiting for the signal, as Sean Puckett suggests.

** Fix Alarm Semantics

There are three ways this could go:

*** New Kernel Functions

Depreciate &Kernel::alarm and &Kernel::delay.  Add these functions to
replace them:

  $alarm_id = $kernel->alarm_set($time, $event, @etc);
  $kernel->alarm_adjust($alarm_id, $seconds_to_adjust);
  $kernel->alarm_remove($alarm_id);
  $alarm_id = $kernel->delay_set($seconds, $event, @etc);

*** New Session Functions

Alarms should really belong to sessions.  What if the Kernel is only
used indirectly?  For that matter, what if all Session resources are
manipulated with Session methods?

  $alarm_id = $session->alarm_set($time, $event, @etc);
  $session->alarm_adjust($alarm_id, $seconds_to_adjust);
  $session->alarm_remove($alarm_id);
  $alarm_id = $session->delay_set($seconds, $event, @etc);

*** Resource Classes

I'm preferring resource classes more and more.  Rather than manipulate
resources with Kernel or Session methods, create them as their own
objects:

  my $alarm = new POE::Alarm($time, $event, @etc);
  $alarm->adjust($seconds_to_adjust);
  undef $alarm; # Calls DESTROY, which replaces alarm_remove()
  my $alarm = new POE::Delay($seconds, $event, @etc);

Resources would be proxy objects: blessed scalars containing the
resource ID.  Their object methods would call the appropriate Kernel
or Session functions to actually manipulate things.  Only the resource
creator would have a reference to the object.

** Break Session Encapsulation

There is a growing need to manipulate remote sessions with
Kernel::signal(), ::alarm(), and :state().  This seems to break the
barriers between sessions in uncomfortable ways, but it appears to
have its uses.

While I can't justify remote signal() and state(), remote alarm() is
harmless enough.  But who gets the $alarm_id when the alarm semantics
change?

** Daemonify a Process

Add a Kernel function to make the whole process go daemon.  From
_Advanced Programming in the UNIX Environment_ by W. Richard Stevens:

  fork() && exit;
  setsid();
  chdir('/');
  umask(0);
  close(STDIN); close(STDOUT); close(STDERR); # if necessary

** "Morphing" SocketFactory

SocketFactory is dead weight after it's made a connection, and its
socket is useless while it's trying to make the connection.  Randal
Schwartz suggests a SocketFactory::put() method that queues data and
delivers it to the socket when it finally connects.

A (UNIX) streams-based approach would handle this nicely.  In the
meantime, two other ideas have been considered:

*** Morphing SocketFactory: First Sortie

After some debate, the idea evolved into a SocketFactory that can
"morph" into another wheel after it successfully connects.
Furthermore, it was suggested that an option to automatically retry
connections might be useful.

Since most of the work is done in the SocketFactory constructor, here
is a sample of what such a beast might look like:

  new POE::Wheel::SocketFactory
                                        # regular SocketFactory things
    ( SocketDomain    => AF_INET,
      SocketType      => SOCK_STREAM,
      SocketProtocol  => 'tcp',
      RemoteAddress   => $remote_address,
      RemotePort      => $remote_port,
      FailureState    => 'io_error',
                                        # here's where it gets strange
      MorphInto       => 'Wheel::ReadWrite',
      MorphParameters => { Driver     => new POE::Driver::SysRW,
                           Filter     => new POE::Filter::Line,
                           InputState => 'got_a_line',
                           ErrorState => 'io_error',
                         },
   );

You sort of need to know what you want to do ahead of time, since
almost all the work's during initialization.  Some folks will find
this concept very strange.

*** Morphing SocketFactory: Second Sortie

I just like saying "sortie".  It comes from long afternoons playing
Choplifter on the Apple ][.  Anyway:

POE::Wheel::SocketFactory would have a put() method, and it would
enqueue output just like the original idea.  However, instead of
playing with the SocketFactory's blessing with the OO equivalent of
goto, provide another method (maybe dequeue_to()) that returns the
queued data as a list.  The list would be suitable for feeding back
into another wheel's put() method.

dequeue_to() might look like this inside:

  sub SocketFactory::dequeue_to {
    my ($self, $new_wheel) = @_;
    if (@{$self->{queue}}) {
      $new_wheel->put(@{$self->{queue}});
      $self->{queue} = [];
    }
    $new_wheel;
  }

You would create a new wheel and pass its reference through the
dequeue_to() function.  This would let you create the new wheel,
dequeue to it, and store it in one statement:

  sub SomeSession::connect_handler {
    my $heap = $_[HEAP];

    $heap->{wheel} =
      $heap->{wheel}->dequeue_to( new Wheel::ReadWrite( ... ) );
  }

This seems cleaner than playing with the SocketFactory's blessing.

** Kernel Statistics

A function to list active sessions.  A function to acquire details
about a session.  A function to acquire the kernel's and OS's load
averages, uptime, etc.

** Port Face from Serv to POE

Face is a text widgets library using Curses.  It's heirarchical, and
it uses a funky slow tied-hash message passing thing.  It would be
enormously cool to revise this and make it work with POE.

* RESEARCH AND DEVELOPMENT

** Object System Architecture

Artur Bergman emphatically recommended the book _Object Database
Development, Concepts and Principles_, by David W. Embley.  More
information about it may be found at
<http://cseng.awl.com/bookdetail.qry?ISBN=0-201-25829-3&ptype=0>.

<http://osm7.cs.byu.edu/~eric/allegro.html> talks about some of the
topics in the book.  Namely "OSA":

  OSA has concepts to formalize just about everything one needs to
  model a real world situation.  Although OSA is an "integrated"
  modeling scheme, that is all the parts work together, it can
  conveniently be seen as consisting of three parts: ORM, OBM, and
  OIM.

  ORM = Object-Relationship Model; OBM = Object-Behavior Model;
  OIM = Object-Interaction Model

** CORBA

For the life of me, I can't remember who was pushing CORBA.  I did
bookmark some links they gave me:

  What CORBA is: <http://www.omg.org/corba/whatiscorba.html>
  Open CORBA: <http://diamant-atm.vsb.cs.uni-frankfurt.de/~mico/>

The one-line descriptions for the CORBA services look like a lot of
fun.  I haven't made time to look at them in detail, though.  I'd like
for the Object Layer to have CORBA capability, if it's possible.
Perhaps something clever could be done to make certain objects
automagically CORBA-compatible.

** Serial and Terminal Device

This amounts to creating pre-conditioned filehandles that the regular
select logic can deal with.  The code is mostly written already; it
just needs to be cleaned up and made available.

Stacked filters would encompass this quite easily.

** State Transition Tables

Crimson would like to see predefined state transition tables.  It
would seem that just adding a transition table to a session isn't
saving much (if any) effort, because the code already knows the
current state, new condition, and desired new state wherever post() is
used.

So, what if there was a wheel to do yacc-like things?  Here's a
preliminary design:

  my $yacker = new POE::Wheel::Yack
    ( $reduction_state_1 => [ [ $token_1, $token_2, $token_3 ],
                              [ $token_1, $token_2 ],
                              [ $token_1 ]
                            ],
      $reduction_state_2 => [ [ $token_4, $token_5 ],
                              [ $token_4 ]
                            ],
      $reduction_state_3 => [ undef ],  # undef signifies end of input
    );

  $yacker->shift($token_1);
  $yacker->shift($token_2);
  $yacker->shift($token_4);
  # Before $yacker shifts $token_4, it first reduces $token_1 and
  # $token_2 to:
  # $kernel->yield($reduction_state_1, 2, $token_1, $token_2);
  $yacker->shift(undef);
  # Reduction: $kernel->yield($reduction_state_2, 1, $token_4);
  # Reduction: $kernel->yield($reduction_state_3, 0);

And of course, reduction states can do all sorts of things.  They can
even shift more tokens.

But what good is a Yack wheel without a lexer?  So how about allowing
it to have one?

  my $yacker = new POE::Wheel::Yack
    ( ..., # Everything from the previous example
      Lexer => new POE::Wheel::Lecks
                 ( Tokens => { $token_1 => [ qr/[a-z][a-z_]/i ],
                               $token_2 => [ qq(+ - * /) ],
                               $token_3 => [ qr/".*?"/ ],
                               $token_4 => [ qq(keyword1 keyword2 keyword3) ],
                               $token_5 => [ qr/[\d+]/ ],
                             },
                   Handle => $filehandle,
                   Driver => new POE::Driver::SysRW()
                 ),
    );

Thus, the Yack wheel will use a Lecks wheel to read data from a Handle
and parse it.  Perhaps Lecks has some default tokens for data not
recognized as one of its Tokens.

** UNIX Streams-Like I/O Abstraction

Randal Schwartz doesn't like the Wheels abstraction.  His needs don't
mesh with it, and he has neither the time nor inclination to write his
own abstraction.  He did take the time to look at it and suggest
things, though.

I like this idea more and more as I think about it.

  He needs something that has callbacks when the listen socket is
  bound.  The bind callback should let him know what port was actually
  bound to, which is useful in the case of binding to any port (0).

  He suggests stream-ish and gram-ish sockets be separate
  Wheel/Driver/Filter groups.  I like this and want to add a third
  group: form-ish.

  He suggests making filters work like SysV drivers.  That is, have a
  low-level socket, then push protocols on top:

    Create a raw socket.
    Push "tcp socket with oob" on it.
    Push "line oriented protocol" on it.
    Push "irc client protocol" on it.

    Create a raw socket.
    Push "tcp with pre-connect buffer" on it.
    Push "line oriented protocol" on it.
    Push "ftp command channel" on it.

    Create a raw tty filehandle.
    Push "cooked mode".
    Push "line oriented".
    Push "irc client".

  So the filter-to-filter protocol must be inclusive enough from the
  start to let users write new filters.

This seems to be more evolved than just chaining filters.  He suggests
reading up on "SysV pushed drivers" and "Unix streams".  Eventually I
will.

** New Modules

*** New Filters

Stacked filters would let you do neat things like IMAP through SSH.
The mind boggles.  Here are some useful filter ideas:

  POE::Filter::SSL
  POE::Filter::SSH

For example:

  Create a raw socket.
  Push "tcp socket" on it.
  Push "SSH stream protocol" on it.
  Push "line oriented protocol" on it.
  Push "imap client protocol" on it.

And go to town!

*** Axels

Axels would let wheels work together, allowing events from one wheel
to be sent to input events in another wheel.  I have no idea what this
might be used for.

*** New Components

Some stand-alone components that might be useful:

**** POE::Component::Cron

This could automate many recurring tasks, using cron records instead
of dorking with time math all the time.  It would also have an at()
method for completeness.

Actually, it'd be kind of silly once the alarms functions were fixed,
but whatever. :)

**** POE::Component::Authenticate

Artur suggests a generic API for authentication servers.  I'm
interpreting this as a new component.  This component would implement
a standard public interface.  Plug-ins for various authentication
servers would do most of the hard work.

Security issues: Kernel hooks can accidentally or maliciously peek at
authentication requests, possibly logging them or otherwise displaying
cleartext passwords.

**** Network Servers and Clients

POE::Component::IRCD, SMTP, SMTPD, NNTP, NNTPD, IMAP, IMAPD, etc.

Sean Puckett has a working prototype of a multi-protocol chat server.
It accepts IRC and MUD style connections, and he spoke of adding web
support.  Everyone shares the same chat stream.

Fimmtiu is the author of Net::IRC.  He has been working on
POE::Component::IRC, and the new module has entered limited beta
testing (as of 6/4/1999).

Filter::HTTP (user agent).  This is the client side.  Randal thinks
there's a non-blocking way to use LWP, possibly by suppling the select
loop logic for it, which would work nicely.

**** POE::Component::Named

This might be a simple Net::DNS wrapper, providing a thin interface to
the module's non-blocking name and number lookup features.

**** POE::Component::VNC

VNC's home is <http://www.uk.research.att.com/vnc/>.

Something on the VNC site caught my eye, but I don't remember exactly
where it is.  The site mentions that the VNC protocol doesn't really
need a desktop behind it.  Instead, stand-alone VNC servers can
provide graphical interfaces to one or more remote clients.

It sure would be interesting if POE could serve virtual desktops or
dialogs with VNC.  Interesting and scary, like a huge, mutant,
radioactive lizard staring in your car window, wondering if maybe it
wants a crunchy snack with a soft, gooey center.  Or something.

** Kernel Extensions

I'd like to see the Kernel be extensible through adding new objects.
Artur has made excellent progress with this, but his code's not ready
for the public yet.

** Exception handling

Artur suggests wrapping event handler invocations in block evals.
This would let them throw exceptions with die, or perhaps an imported
throw function which dies internally.

The caught exception would be translated into an exception event, and
posted or called back to the session.  Or maybe translated into a
warning.

** Concurrent POE (Distributed Queue)

How does POE transparently thread or fork if these concurrency methods
are available?  How does it make concurrent and single-threaded modes
compatible with each-other?

Enqueue events in sessions instead of the Kernel.  This change should
also allow sessions to be frozen and thawed, since freezing them will
also freeze their event queues.  Other resources, such as files, may
be lost, however.  A work-around might be to have special _freeze and
_thaw states that are called at appropriate times.  They can clean up
and reallocate resources.

Function name conventions used in the following code snippets:

  sub name is public
  sub _name is friend
  sub __name is private

*** Kernel Changes

  sub _enqueue_event {
    my ($self, $session_id, $source_id, $state, $priority, $time, $etc) = @_;
  }

  #----------------------------------------------------------------------------
  # Dispatch an event to the next session in the round-robin queue.
  # This also has the side-effect of testing sessions for activity; they
  # can be checked for resource starvation only when they've run out of
  # events.  This should eliminate a lot of checks.

  sub _dispatch_next_event {
    my ($self) = @_;

    my $next_session = shift @{$self->[KR_SQUEUE]};
    if ($next_session->_dispatch_event()) {
      push @{$self->[KR_SQUEUE]}, $next_session;
    }
  }

  # Theory of operation:
  #
  # Kernel keeps a master queue.  This holds active sessions in a
  # time-based "priority" queue.
  #
  # The queue's "key" is the time that a session will next need
  # attention.  This is the time of the next event in the session's
  # queue.
  #
  # The queue's "value" is a reference to the session (or perhaps
  # session ID) that points to the session for dispatching.
  #
  # So:

  my $kernel = bless {}, 'POE::Kernel';
  $kernel->[KR_MASTER_QUEUE] =
    [ [ $time, $session ],
      [ $time, $session ],
      ...
    ];

  # Sorted in $time order.
  #
  # Inser

*** Session Changes

  #----------------------------------------------------------------------------
  # Enqueue an event.

  sub _enqueue_event {
    my ($self, $sender, $state, $priority, $time, $etc) = @_;

    # Place the event is the session's queue.

    #
    # If "concurrent" POE:
    #   Start or unblock the session's dispatch thread.
    # End
    #
    # Return the number of events in the session's queues.

  }

  sub _dispatch_event {
    my ($self) = @_;

    # If "concurrent" POE:
    #   Return 1 if there are no events but the session has resources
    #   to keep it active, or return 0 if there are no events and the
    #   session is "stalled".
    # Otherwise, "regular" POE:
    #   Dispatch an event, and return the number of events left in the
    #   queue.
    # End
  }

** Unique IDs

Kernels need some unique ID.  Perhaps a directory service could be set
up so that kernels can do name lookup.  Maybe regular DNS + port
number could work.

I'm of two minds with regards to Session IDs.

*** No Unique Session IDs

Sessions are just threads for the Object Layer.  When talking between
POE systems, the unit of code is an Object.  For example, you wouldn't
talk to a specific remote thread in a program.  Instead, you'd talk to
a particular object (or program), and threads are created and
destroyed as necessary.

*** Unique Session IDs in the POE Core

On the other hand, it's useful to know what's running in your Kernel,
so session IDs are good for ps-like things.  Also, a lot of people use
sessions as code objects.  This is my fault, because I blurred the
distinction early on.

A POE::Component would be good.  Register a session with the
Component, and let the Component deal with publishing, retracting and
event emitting/catching.

* WILD IDEAS

** Scheme

Write a virtual scheme machine that compiles into POE sessions.
Sessions can emulate callcc (call-with-current-continuation), which in
turn emulates everything, so it's theoretically possible.

** "Organic" FSA

POE::Session instances are finite state automata.  They are permitted
to modify themselves at runtime.  Is there an elegant way to encode
decisions in POE::Session instances, perhaps in a way that can modify
itself over time?

For example, a neural network could be encoded in a POE::Session, one
neuron per state.  Neurons would fire events at each-other, in massive
simulated parallelism.

Neural networks implemented this way are also dynamic, because
sessions may add, remove and redefine their states.  There just isn't
a handy way to define this particular POE use yet.

** "AutoPOE"

AutoPOE would implement Philip Gwyn's idea to auto-split and translate
Perl code into POE event handlers as part of an installation process,
rather than at runtime.  Sort of an autoloader/selfloader that also
transforms code into POE sessions.

** POE::Perl

POE::Perl would take a different approach.  It would try to manipulate
Perl into cooperating with POE's event model.  So far, the idea
includes:

*** Overriding Perl's built-in functions

CORE::GLOBAL::sleep, for example, would register an alarm handler, and
set an alarm for it.

*** Manipulating Perl's call stack

CORE::GLOBAL::sleep (again, for example) would save the call stack
going into the sleep() function, and simulate a return back to the
kernel.  When the alarm handler is called, the stack is reconstituted,
and CORE::GLOBAL::sleep returns back to the session.

That's the idea, anyway.  Perl may not like it.

** Automate State Creation

***Translate plain procedural perl into POE event handlers

There is an easy way to translate blocking code into non-blocking
code.  You just need identify all the jump/return destinations, and
start new states at them.

For example, consider this perl code:

  my $count = 1_000_000_000;
  while ($count--) {
    print "Hello, world!  Enter some text: ";
    my $line = <STDIN>;
    last if ($line =~ /^quit$/i);
  }
  print "Goodbye, world!\n";

This could be represented by the following states:

  sub _start {
    $_[HEAP]->{count} = 1_000_000_000;
    $_[KERNEL]->yield('while_test_1');
  }

  sub while_test_1 {
    if ($_[HEAP]->{count}--) {
      $_[KERNEL]->yield('end_of_while_1');
    }
    print "Hello, world!  Enter some text: ";
    $_[KERNEL]->block('line input', 'resume_state');
  }

  sub resume_state {
    if ($_[ARG0] =~ /^quit$/i) {
      $_[KERNEL]->yield('end_of_while_1');
    }
    else {
      $_[KERNEL]->yield('while_test_1');
    }
  }

  sub end_of_while_1 {
    print "Goodbye, world!\n";
  }

B::Deparse returns "normalized" Perl based on the bytecodes in perl's
compiled parse trees.  It may be easier to convert normalized Perl
into states than to try and parse everyone's different coding styles.

Here's the original Perl code, run through `perl -MO=Deparse,-p`:

  (my($count) = 1000000000);
  while (($count--)) {
      print('Hello, world!  Enter some text: ');
      (my($line) = <STDIN>);
      (($line =~ /^quit$/i) and last);
  }
  print("Goodbye, world!\n");

More research is needed here.  Must test more code constructs; maybe
run a large program through B::Deparse and see how it treats things.

** Load Balancing Among Distributed POE Kernels

Some ueber-kernel directory service would keep track of everything,
maybe, and, uh, make sure stuff works.  :)

** Input Parsing (Factoid Style)

*** The Problem

Input parsing is hard.  I have some prototype code for Infocom-style
command parsing, but it doesn't scale well when you consider that that
existing infobots (see <http://www.cs.cmu.edu/~infobot>) already
manage around 150,000 factiods.

So consider the need to look up responses in a 150,000 factoid
database.  This isn't so far-fetched; there's an IRC 'bot that does
this now with a tied hash (I think; haven't looked).  Its limitation,
however is that it can't perform "fuzzy" matches on user input.

Consider the example:

  can someone help me?

There are a number of different ways to represent it, and they can be
summarized succintly as a regexp:

  /^can some(one|body) help( me)?$/

So the question is: how do I key a hash by regexp?  The answer is: I
can't.  But there seems to be a limited regexp style that might work.
Instead of using the full regexp syntax, I limit it to just (|).
Begin and end anchors are implied, and I leave out some bits.

  (can|would) (someone|somebody|anyone|anybody) (help|assist) (|me)

Pretty rough.  How to make that pattern a factoid key, so that someone
asking the original question triggers the response.

*** Factoid Storage

First we treat the factoid key as a series of words instead of a
string of letters.  This removes the whitespace dependency:

  (can|would), (someone|somebody|anyone|anybody), (help|assist), (|me)

Second, we sort options lexically, so that (can|would) and (would|can)
are treated the same:

  (can|would), (anybody|anyone|somebody|someone), (assist|help), (|me)

Third, we build a hash of discrete words to the option groups they
occur in.  I have some doubts about this, but it's my best idea so
far:

  $alias{'can'}   = [ 'can',   'can|would' ];
  $alias{'would'} = [ 'would', 'can|would' ];

  $alias{'someone'}  => [ 'someone',  'anybody|anyone|somebody|someone' ];
  $alias{'anyone'}   => [ 'anyone',   'anybody|anyone|somebody|someone' ];
  $alias{'somebody'} => [ 'somebody', 'anybody|anyone|somebody|someone' ];
  $alias{'anybody'}  => [ 'anybody',  'anybody|anyone|somebody|someone' ];

  $alias{'help'}   => [ 'help',   'assist|help' ];
  $alias{'assist'} => [ 'assist', 'assist|help' ];

  $alias{'me'} => [ 'me', '|me' ];

Fourth, the factoid is stored under list of words and sorted options
(the results from the second step):

  $factoid{ 'can|would', 'anybody|anyone|somebody|someone',
            'assist|help', '|me'
          } = 'No! Go away!';

*** Information Retrieval

Retrieving factoids is a little harder.  Let's review the target
input, preprocessed as a list of words (punctuation handily
discarded):

  'can', 'someone', 'help', 'me'

Here's the query (pseudo-SQL):

  select factoid from factoids
   where key.word_1 is in
         ( select alias from aliases where key=='can' )
     and key.word_2 is in
         ( select alias from aliases where key=='someone' )
     and key.word_3 is in
         ( select alias from aliases where key=='help' )
     and key.word_4 is in
         ( select alias from aliases where key=='me' )

And then pick the factoid with the shortest/longest key?

Actually, this fails for (|me) things, because the select will look
for four words.  So I suppose what's really needed is an index that
works in the same vein as regexps do for matching.  Somehow.

So, the query:

  qw(can someone help me)

somehow matches a factoid stored by:

  qw(can|would anybody|anyone|somebody|someone assist|help |me)

Hrm.  I've decided it's going to take some experimentation, which
means having a framework for tinkering.  And the best framework for
tinkering with NLP/factoid stuff is a 'bot!  And the best way to have
a 'bot that you don't have to reset all the time is (IMO) the fabled
Object Layer.

So, this to-do is on hold 'til I can build an IRC 'bot.

* IN CLOSING

I welcome all ideas, suggestions and research pointers.
