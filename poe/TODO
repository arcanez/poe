$Id$

Things to do to POE, many of which will break existing programs.
Please use POE's mailing list (see the main POE manpage) to comment on
proposed changes.

=========================================
Depreciations & Changes In Progress (!!!)
=========================================

These changes have begun, or will shortly.  Their remaining steps are
still open to discussion, but the changes will go through in one form
or another.

--------------------
XyzState to XyzEvent
--------------------

In the wheels, rename XyzState to XyzEvent everywhere.  Wheels don't
define states, they emit events.  Callivg Wheels' parameters XyzState
has been inconsistent and confusing.  It's bitten a lot of people.
Call them what they are instead.

To do:

* Release version 0.15, and announce the depreciation.

* Wait at least 28 days (until ????.??.??) before continuing this
  change schedule.  This gives people time to adapt their production
  code to the new parameters before warnings start.

* Add depreciation warnings when XyzState is used.  This will prompt
  late developers to adapt their code.

* Release version ?.??, and announce the next phase of XyzState
  depreciation.

* Wait at least 28 days (until ????.??.??) before continuing this
  change schedule.  This gives people time to adapt their production
  code to avoid the depreciation warnings and subsequent breakage.

* Remove XyzState warnings and support altogether.

* Release version ?.??, and announce that the XyzState to XyzEvent
  depreciation has been completed.

------------------------------------
Signal Handler Return Values Must Go
------------------------------------

Signal handlers' return values are significant, determining whether
the handler has handled a signal, which in turn determines whether the
session will survive a terminal signal dispatch.  This is the only
time where a state/event handler's return value is significant within
POE itself, and it's incongruous with the rest of the library.  It's
also really easy to accidentally handle (or not) a signal by mistake:
simply implicitly return some random value.

To do:

* Add a POE::Kernel method: handle_signal().

  This will indicate that the currently dispatched signal has been
  handled for the session.  Should it also affect all sessions?  For
  example, if one session handles SIGINT, would they all remain alive?

* Change the documentation to list handle_signal() as the proper way
  to handle terminal signals.

* Run a complete test/coverage suite to make sure the current signal
  handling code is not broken in the process of adding the new code.

* Add new tests for handle_signal() to make sure it works, and run a
  complete test/coverage suit to verify that.

* Port the samples to use handle_signal() instead of return values.

* Release version ?.??, and announce the depreciation.

* Wait at least 28 days (until ????.??.??) before continuing this
  change schedule.  This gives people time to adapt their production
  code to the new signal handling method before the warnings start.

* Add depreciation warnings whenever a terminal signal is handled by
  its return value instead of the new handle_signal() method.

* Release version ?.??, and announce the next phase of the signal
  handler depreciation.

* Wait at least 28 days (until ????.??.??) before continuing this
  change schedule.  This gives people time to adapt their production
  code to avoid the depreciation warnings and subsequent breakage.

* Remove the code to recognize implicit signal handling due to
  handlers' return values, making the handle_signal() method the only
  way to do this.

* Release version ?.??, and announce that signal handlers' return
  values have been completely depreciated.

==================================================
Depreciations & Changes Currently Being Considered
==================================================

These changes are under consideration.  They have not begun, and they
may not ever be made.  These are proto-plans being considered and made
ready for deployment.

-----------------------
Improve Alarm Interface
-----------------------

Swapped event/time in alarm_set() and event/seconds in delay_set()
based on feedback from Kirill.

Added alarm_remove_all() to clear all alarms, based on feedback from
Kirill.  I'm not sure how useful this one will be.

> From troc@netrus.net Thu Mar 18 09:20:36 1999
> Message-Id: <199903181417.JAA09983@mail.netrus.net>
> From: "Rocco Caputo" <troc@netrus.net>
> To: "The POE Mailing List" <poe@vogon.se>
> Date: Thu, 18 Mar 99 09:17:02 -0500
> Subject: TODO: fix alarms
>
> [...]  If there are no objections, this will go into 0.07_01 or so,
> depending on my schedule.  [...]
>
> | ***fix alarm semantics (in a way that does not break things)
> |
> | That's easy to say, anyway.  How about depreciating &Kernel::alarm
> | and &Kernel::delay, and adding these functions?

      $alarm_id = $kernel->alarm_set($event, $time, @etc);
      $status = $kernel->alarm_adjust($alarm_id, $seconds_to_adjust);
      $status = $kernel->alarm_remove($alarm_id);

> | Also the delay shortcut, which would return an ID usable by
> | &Kernel::alarm_adjust and &Kernel::alarm_remove:
> | 
> |   $alarm_id = $kernel->delay_set($event, $seconds, @etc);

To remove all alarms for a given event or time.  I'm not sure how
useful these are yet.

      $status = $kernel->alarm_remove_by_event($event);
      $status = $kernel->alarm_remove_by_time($time);

To remove all alarms for the current session:

      $status = $kernel->alarm_remove_all();

Should alarm_remove() be alarm_remove_by_id() ?

Needless to say, this didn't make it into 0.07_01 (see the CHANGES
file for what did).  Anyway, the interface seems to have survived the
test of time: I still like it, and so do others who have seen it.

Internally, I'd maintain yet another hash: %kr_alarm_id_to_time, which
would be keyed on alarm ID and contain the corresponding alarm time
for that ID.  The alarm_xyz() methods would manage the time: adjust
would adjust it, etc., so it always matches the time in the queue.

The implementation can reuse the linear/binary seek code from
_enqueue_alarm to find alarms by time (id->time lookup above) and
remove/add/adjust alarms relatively quickly.  Ideally, though, it's
possible to schedule delayed alarm queue sweeps.  I'd like to try that
after some more planning.  See "Delay Garbage Collection" elsewhere in
this file.

The old alarm interface would be depreciated.  Perhaps it would be
reimplemented as a layer atop the new interface, for compatibility,
and then be depreciated.

-----------------
ARG0..ARG9 May Go
-----------------

HEAP, KERNEL, SESSION, and the other event handler parameter constants
were introduced to eliminate a dependence on their positions in @_.
However, the ARG0..ARG9 parameters aren't descriptive and still
contain position dependence.  This robs event parameters of many of
the benefits of using symbolic constants in the first place.

This is the current plan to depreciate them:

* Introduce new constants for the different built-in events.  Leave
  ARG0..ARG9 for user parameters.

* Document the new constants instead of ARG0..ARG9.

* Document that parameters may move around in the future, so their
  positions in ARG0..ARG9 will not be guaranteed.

* Release version ?.??.

* Wait at least 28 days (until ????.??.??) before continuing this
  depreciation schedule, to give people time to react to the initial
  round of changes.

* Generate warnings when ARG0..ARG9 are used for built-in events.
  This will require some logic within those subs, removing their
  constant nature and slowing things down in general.

* Release version ?.??, and announce that the ARG0..ARG9 built-in
  parameter depreciation is proceding apace.

* Wait at least 29 days (until ????.??.??) before continuing this
  depreciation schedule, to give people time to react to the warnings
  and adapt their code to the new symbolic constants.

* Remove the warnings from ARG0..ARG9, making them constants again and
  speeding things up once more.

* Release version ?.??, and announce that the ARG0..ARG9 built-in
  parameter depreciation has completed.

----------------------------
Spin Off Useful Technologies
----------------------------

POE only really needs a few modules.  The rest are options which may
not always be needed, or they're stand-alone modules that someone else
may find useful.  For example, POE::Filter::*; POE::Preprocessor; and
POE::Pipe::* are useful by themselves.  Wheels are pretty useful, but
they're not always necessary.  It may be both useful and convenient to
split POE into smaller distributions and present one or more Bundles
to selectively load just the parts that are needed.

This is the current plan to spin off useful modules from POE:

* Develop a real plan for this.  Most of this is tentative.

* Organize subsets of POE into useful bundles, and document them.
  Make Bundle::POE the default.

* Split out wheels?

* Split out the Preprocessor?  Should it remain a POE::* module?

* Split out filters?  They're useful by themselves; should they remain
  POE::* modules?

* The samples are huge and obscure.  Split them into a separate
  distribution which doesn't install itself.

* Most of the documentation is theory and usage, and it doesn't really
  fit in manpages for modules themselves.  Split it into separate POD
  files, and maybe split them into Bundle::POE::Docs.

-----------------------------------------
Make Driver::SysRW the Default for Wheels
-----------------------------------------

This is a quick, inexpensive change.  Driver::SysRW is the only driver
to be developed/used over the course of like three years.  Make it a
default so people can stop typing it.

----------------------------------------
Make Filter::Line the Default for Wheels
----------------------------------------

This is an inexpensive change, but it has dubious value.  Think about
it some more first.

----------------------------------------------------
Split Dual-Mode Functions into xyz_set and xyz_clear
----------------------------------------------------

This would make the functions' purposes more clear and eliminate some
branches that are currently tested all the time.  The existing
dual-mode functions could remain as thunks for the single-purpose
ones.

-----------------------------------------------------------
Evaluate Torvald Riegel's Throttled ReadWrite Wheel Patches
-----------------------------------------------------------

Torvald has the code, but I'm not happy with the idea of ReadWrite
buffering data.  Is there another way, or does Torvald's code really
make the most sense?  Should this be beyond the scope of ReadWrite and
something left for a better wheel?

------------------------
Delay Garbage Collection
------------------------

POE's garbage collection can be slow.  It would be very cool to
schedule this in the "dead" time between events.  Especially in
instances where the next event is a timer and we have a few seconds of
nothing to do.

A lot of things rely on timely garbage collection, though.  _parent
and _child events.  Referential integrity.  Things would be a mess
between _stop and the delayed garbage collection.

Delaying alarm GC might be doable.  We can flag alarms as "dead" in
the ID->time hash and discard them as they come to the front of the
queue.  In idle times when there are no FIFO events and the next alarm
is more than 1/10 second away, we can sweep the alarm queue and pull
out the dead ones.

It will take a fair amount of planning to pull this off correctly.
I'm just documenting it for now so I don't forget.

===
EOT
===
